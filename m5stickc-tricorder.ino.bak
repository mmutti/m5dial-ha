
#include <M5StickCPlus.h>
#include "Unit_MiniEncoderC.h"
#include <SensirionI2cScd4x.h>
#include <bsec2.h>
#include <Adafruit_SGP30.h>
#include <Adafruit_MLX90614.h>
#include "MAX30105.h"
#include "heartRate.h"
#include <VL53L0X.h>
#include "UNIT_SCALES.h"
#include <Wire.h>
#include <Preferences.h>
#include <WiFi.h>
#include <PubSubClient.h>
#include <WebServer.h>
#include <LittleFS.h>
#include <sunset.h>
#define IR_SEND_PIN 9
#define IR_RECEIVE_PIN 36
#include <IRremote.hpp>
#define NOTE_B0  31
#define NOTE_C1  33
#define NOTE_CS1 35
#define NOTE_D1  37
#define NOTE_DS1 39
#define NOTE_E1  41
#define NOTE_F1  44
#define NOTE_FS1 46
#define NOTE_G1  49
#define NOTE_GS1 52
#define NOTE_A1  55
#define NOTE_AS1 58
#define NOTE_B1  62
#define NOTE_C2  65
#define NOTE_CS2 69
#define NOTE_D2  73
#define NOTE_DS2 78
#define NOTE_E2  82
#define NOTE_F2  87
#define NOTE_FS2 93
#define NOTE_G2  98
#define NOTE_GS2 104
#define NOTE_A2  110
#define NOTE_AS2 117
#define NOTE_B2  123
#define NOTE_C3  131
#define NOTE_CS3 139
#define NOTE_D3  147
#define NOTE_DS3 156
#define NOTE_E3  165
#define NOTE_F3  175
#define NOTE_FS3 185
#define NOTE_G3  196
#define NOTE_GS3 208
#define NOTE_A3  220
#define NOTE_AS3 233
#define NOTE_B3  247
#define NOTE_C4  262
#define NOTE_CS4 277
#define NOTE_D4  294
#define NOTE_DS4 311
#define NOTE_E4  330
#define NOTE_F4  349
#define NOTE_FS4 370
#define NOTE_G4  392
#define NOTE_GS4 415
#define NOTE_A4  440
#define NOTE_AS4 466
#define NOTE_B4  494
#define NOTE_C5  523
#define NOTE_CS5 554
#define NOTE_D5  587
#define NOTE_DS5 622
#define NOTE_E5  659
#define NOTE_F5  698
#define NOTE_FS5 740
#define NOTE_G5  784
#define NOTE_GS5 831
#define NOTE_A5  880
#define NOTE_AS5 932
#define NOTE_B5  988
#define NOTE_C6  1047
#define NOTE_CS6 1109
#define NOTE_D6  1175
#define NOTE_DS6 1245
#define NOTE_E6  1319
#define NOTE_F6  1397
#define NOTE_FS6 1480
#define NOTE_G6  1568
#define NOTE_GS6 1661
#define NOTE_A6  1760
#define NOTE_AS6 1865
#define NOTE_B6  1976
#define NOTE_C7  2093
#define NOTE_CS7 2217
#define NOTE_D7  2349
#define NOTE_DS7 2489
#define NOTE_E7  2637
#define NOTE_F7  2794
#define NOTE_FS7 2960
#define NOTE_G7  3136
#define NOTE_GS7 3322
#define NOTE_A7  3520
#define NOTE_AS7 3729
#define NOTE_B7  3951
#define NOTE_C8  4186
#define NOTE_CS8 4435
#define NOTE_D8  4699
#define NOTE_DS8 4978
#define REST      0


TFT_eSprite tftSprite = TFT_eSprite(&M5.Lcd);
UNIT_MINIENCODERC sensor;
SensirionI2cScd4x scd4x;
Preferences prefs;

uint16_t delay_time = 0;
int32_t last_value  = 0;

uint8_t i2c_address = 0;

// App system
enum AppState { APP_RUNNING, APP_MENU };
enum AppID { APP_AIR_QUALITY, APP_STOPWATCH, APP_TIMER, APP_MOTION, APP_NCIR, APP_HEARTRATE, APP_IR_REMOTE, APP_LEVEL, APP_DISTANCE, APP_TOF_COUNTER, APP_SCALE, APP_WEB_FILES, APP_SUN_MOON, APP_HOME_ASSISTANT, APP_SETTINGS, APP_POWER_OFF, APP_COUNT };
const char* appNames[] = { "Air Quality", "Stopwatch", "Timer", "Motion", "NCIR Temp", "Heart Rate", "IR Remote", "3D Level", "Distance", "TOF Counter", "Scale", "Web Files", "Sun & Moon", "Home Assist", "Settings", "Power Off" };
bool appEnabled[APP_COUNT] = { false, true, true, false, false, false, true, true, false, false, false, true, true, true, true, true };  // Detected at startup

// I2C addresses for sensor detection
#define SCD4X_I2C_ADDR 0x62
#define SGP30_I2C_ADDR 0x58       // TVOC/eCO2 unit
#define MLX90614_I2C_ADDR 0x5A
#define MAX30102_I2C_ADDR 0x57
#define VL53L0X_I2C_ADDR 0x29
#define MINISCALE_I2C_ADDR 0x26
#define BME68X_I2C_ADDR_HIGH 0x77  // ENV Pro unit (SDO high)
#define BME68X_I2C_ADDR_LOW 0x76   // ENV Pro unit (SDO low)
#define PIR_DETECTED_PIN 33  // PIR is digital, not I2C

// Home Assistant configuration
// Credentials are in credentials.h (gitignored) - copy from credentials.h.example
#include "credentials.h"
#define HA_MQTT_COMMAND_TOPIC "home/alarm/set"
#define HA_MQTT_STATE_TOPIC "home/alarm"
#define HA_MQTT_STATUS_TOPIC "home/alarm/status"

// Binary sensors for alarm (doors/windows)
#define HA_SENSOR_COUNT 11
const char* haSensorTopics[HA_SENSOR_COUNT] = {
    "home-assistant/porta_ingresso/contact",
    "home-assistant/portafinestra_cucina/contact",
    "home-assistant/portafinestra_corridoio/contact",
    "home-assistant/finestra_bagno_pt/contact",
    "home-assistant/finestra_ingresso/contact",
    "home-assistant/finestra_scale/contact",
    "home-assistant/portafinestra_camera/contact",
    "home-assistant/finestra_camera_bimbe/contact",
    "home-assistant/finestra_studio/contact",
    "home-assistant/finestra_camera/contact",
    "home-assistant/finestra_bagno_p1/contact"
};
const char* haSensorNames[HA_SENSOR_COUNT] = {
    "Porta ingresso",
    "PF cucina",
    "PF corridoio",
    "Fin bagno PT",
    "Fin ingresso",
    "Fin scale",
    "PF camera",
    "Fin camera bimbe",
    "Fin studio",
    "Fin camera",
    "Fin bagno P1"
};

// I2C bus pins
// Internal I2C (Wire1): GPIO 21 SDA, GPIO 22 SCL - used by AXP192 and RTC, DO NOT RECONFIGURE
// Grove port (external): GPIO 32 SDA, GPIO 33 SCL
// Encoder Qwiic port: GPIO 0 SDA, GPIO 26 SCL
// Note: PIR_PIN (33) conflicts with Grove SCL - PIR cannot be used when Grove I2C is active
#define GROVE_SDA 32
#define GROVE_SCL 33
#define QWIIC_SDA 0
#define QWIIC_SCL 26

// Internal I2C pins used by AXP192 and RTC (managed by M5.begin())
#define INTERNAL_SDA 21
#define INTERNAL_SCL 22

// Flag to track if Grove port is used for I2C (disables PIR)
bool groveUsedForI2C = false;

// Track current Wire1 configuration (for bus switching when Grove sensors are used)
enum Wire1Mode { WIRE1_INTERNAL, WIRE1_GROVE };
Wire1Mode currentWire1Mode = WIRE1_INTERNAL;

// Helper functions to switch Wire1 between internal (AXP192/RTC) and Grove port
void switchWire1ToInternal() {
    if (currentWire1Mode != WIRE1_INTERNAL) {
        Wire1.end();
        Wire1.begin(INTERNAL_SDA, INTERNAL_SCL, 400000UL);
        currentWire1Mode = WIRE1_INTERNAL;
    }
}

void switchWire1ToGrove() {
    if (currentWire1Mode != WIRE1_GROVE) {
        Wire1.end();
        Wire1.begin(GROVE_SDA, GROVE_SCL, 100000UL);
        currentWire1Mode = WIRE1_GROVE;
    }
}

// Flag to track if encoder is connected
bool encoderConnected = false;

// Track which bus each sensor is on (NULL = not detected)
TwoWire* scd4xBus = NULL;
TwoWire* sgp30Bus = NULL;
TwoWire* mlxBus = NULL;
TwoWire* heartRateBus = NULL;
TwoWire* tofBus = NULL;
TwoWire* envProBus = NULL;

// SGP30 TVOC/eCO2 sensor
Adafruit_SGP30 sgp30;
bool sgp30Initialized = false;
uint16_t sgp30TVOC = 0;      // TVOC in ppb
uint16_t sgp30eCO2 = 0;      // eCO2 in ppm
unsigned long sgp30LastRead = 0;
#define SGP30_READ_INTERVAL 1000  // Read every 1 second as per datasheet

// ENV Pro sensor (BME688 with BSEC2)
Bsec2 envProSensor;
bool envProInitialized = false;
uint8_t envProI2CAddr = 0;  // Detected I2C address (0x76 or 0x77)
float envProIAQ = 0.0;
uint8_t envProIAQAccuracy = 0;
float envProTemperature = 0.0;
float envProHumidity = 0.0;
float envProPressure = 0.0;
float envProGasResistance = 0.0;
bool envProStabilized = false;
bool envProRunIn = false;

// TOF sensor (VL53L0X)
VL53L0X tofSensor;
uint16_t tofDistance = 0;  // Current distance in mm
bool tofInitialized = false;

// TOF Counter app state
uint32_t tofCount = 0;
uint16_t tofThresholdNear = 200;   // Object detected when closer than this (mm)
uint16_t tofThresholdFar = 400;    // Object left when farther than this (mm)
bool tofObjectPresent = false;     // Currently detecting an object
uint16_t tofMinDistance = 8190;    // Track min distance during detection cycle
uint16_t tofMaxDistance = 0;       // Track max distance

// MiniScale sensor
UNIT_SCALES scales;
TwoWire* scalesBus = NULL;
bool scalesInitialized = false;
float scaleWeight = 0.0;
float scaleGapValue = 1.0;  // Calibration gap value

// NCIR temperature sensor
Adafruit_MLX90614 mlx = Adafruit_MLX90614();

// Heart rate sensor
MAX30105 heartRateSensor;
int32_t heartBPM = 0;
int32_t heartBPMAvg = 0;
bool fingerDetected = false;
const byte HR_RATE_SIZE = 4;
byte hrRates[HR_RATE_SIZE];
byte hrRateSpot = 0;
byte hrValidReadings = 0;  // Track how many valid readings we have
long hrLastBeat = 0;

// Custom beat detection variables
long hrIrPrev = 0;
long hrIrDelta = 0;
long hrIrDeltaPrev = 0;
bool hrBeatState = false;  // true = in beat (rising), false = between beats

// Heart rate history for 12h graph (sample every 5 min = 144 points)
#define HR_HISTORY_SIZE 144
#define HR_SAMPLE_INTERVAL_MS 300000  // 5 minutes in ms
uint8_t hr_history[HR_HISTORY_SIZE];  // Store BPM values (0-255)
uint8_t hr_history_index = 0;
uint8_t hr_history_count = 0;
unsigned long hr_last_sample_time = 0;

// HR Min/Max tracking with timestamps
uint8_t hr_min_12h = 255;
uint8_t hr_max_12h = 0;
uint8_t hr_min_hour = 0, hr_min_min = 0;
uint8_t hr_max_hour = 0, hr_max_min = 0;

// IR Remote - M5StickC Plus has IR LED on GPIO 9, receiver on GPIO 36

// IR command storage
#define IR_MAX_COMMANDS 10
#define IR_NAME_LEN 12
struct IRCommand {
    char name[IR_NAME_LEN];
    uint32_t code;
    uint8_t bits;
    uint8_t protocol;  // Store as uint8_t for compatibility
    bool used;
};
IRCommand irCommands[IR_MAX_COMMANDS];
uint8_t irCommandCount = 0;
int8_t irSelectedCmd = 0;
enum IRAppState { IR_LIST, IR_LEARNING, IR_NAMING };
IRAppState irAppState = IR_LIST;
bool irLearning = false;
char irNewName[IR_NAME_LEN] = "Cmd";
uint8_t irNamePos = 3;  // Cursor position in name

// Web Files app - WiFi AP and web server for file management
WebServer webFilesServer(80);
bool webFilesWiFiEnabled = false;
const char* WEB_FILES_SSID = "m5stickc-tricorder";
const char* WEB_FILES_PASSWORD = "tr1c0rd3r!";
#define WEB_FILES_MAX_FILES 30
#define WEB_FILE_NAME_LEN 64
char webFilesList[WEB_FILES_MAX_FILES][WEB_FILE_NAME_LEN];
uint8_t webFilesCount = 0;
int8_t webFilesSelectedFile = 0;
enum WebFilesAppState { WEBFILES_MAIN, WEBFILES_LIST, WEBFILES_WIFI_ON };
WebFilesAppState webFilesAppState = WEBFILES_MAIN;

// IR Remote - Flipper IR file support
#define IR_FILE_MAX_CMDS 50
#define IR_FILE_CMD_NAME_LEN 24
struct FlipperIRCmd {
    char name[IR_FILE_CMD_NAME_LEN];
    uint8_t protocol;  // 0=NEC, 1=Samsung, 2=Sony, 3=RC5, 4=RC6, 5=LG, 6=Panasonic
    uint32_t address;
    uint32_t command;
    bool valid;
};
char irFilesList[WEB_FILES_MAX_FILES][WEB_FILE_NAME_LEN];
uint8_t irFilesCount = 0;
char irCurrentFileName[WEB_FILE_NAME_LEN] = "";
FlipperIRCmd irFileCommands[IR_FILE_MAX_CMDS];
uint8_t irFileCommandCount = 0;
int8_t irFileSelectedCmd = 0;
int8_t irFileSelectedFile = 0;
enum IRFileState { IRFILE_NONE, IRFILE_SELECT_FILE, IRFILE_SELECT_CMD };
IRFileState irFileState = IRFILE_NONE;

// 3D Level app state (uses built-in MPU6886 IMU)
float levelPitch = 0, levelRoll = 0, levelYaw = 0;
float levelRefPitch = 0, levelRefRoll = 0, levelRefYaw = 0;
bool levelAlarmArmed = false;
float levelAlarmThreshold = 5.0;  // Degrees of change to trigger alarm
bool levelAlarmTriggered = false;

AppState appState = APP_RUNNING;
AppID currentApp = APP_AIR_QUALITY;
int8_t menuSelection = 0;
int32_t menuEncoderBase = 0;  // Encoder value when menu opened

// Stopwatch app state
unsigned long stopwatchStartTime = 0;
unsigned long stopwatchElapsed = 0;
bool stopwatchRunning = false;

// Timer (countdown) app state
enum TimerState { TIMER_SETTING, TIMER_RUNNING, TIMER_PAUSED, TIMER_FINISHED };
TimerState timerState = TIMER_SETTING;
unsigned long timerDuration = 60000;  // Default 1 minute in ms
unsigned long timerStartTime = 0;
unsigned long timerRemaining = 0;
int32_t timerEncoderBase = 0;
unsigned long lastAlarmTone = 0;
uint8_t alarmToneIndex = 0;

// Motion sensor app state
// Grove port on M5StickC Plus: GPIO 32 (data), GPIO 33 (clock/data2)
#define PIR_PIN 33
bool motionArmed = false;
bool motionDetected = false;
unsigned long lastMotionTime = 0;

// Settings app state
enum SettingsField { SET_HOUR, SET_MIN, SET_DAY, SET_MONTH, SET_YEAR, SET_FIELD_COUNT };
SettingsField settingsField = SET_HOUR;
int32_t settingsEncoderBase = 0;
bool settingsEditing = false;  // true when actively editing a field

// Home Assistant app state
enum HAState { HA_DISCONNECTED, HA_CONNECTING, HA_CONNECTED, HA_SENDING, HA_SUCCESS, HA_ERROR };
HAState haState = HA_DISCONNECTED;
bool haWiFiEnabled = false;
unsigned long haConnectStartTime = 0;
unsigned long haStatusDisplayTime = 0;
String haLastError = "";
String haAlarmState = "unknown";  // Current alarm state from MQTT
bool haSensorOpen[HA_SENSOR_COUNT] = {false};  // Track open sensors
#define HA_CONNECT_TIMEOUT_MS 15000
#define HA_STATUS_DISPLAY_MS 2000

// MQTT client
WiFiClient haWifiClient;
PubSubClient haMqttClient(haWifiClient);

// Long press detection
#define LONG_PRESS_MS 500
unsigned long btnA_press_start = 0;
bool btnA_was_pressed = false;
bool btnA_long_triggered = false;  // Track if long press was already handled
unsigned long enc_btn_press_start = 0;
bool enc_btn_was_pressed = false;
bool enc_long_triggered = false;  // Track if long press was already handled

// CO2 sensor values
uint16_t co2_value = 0;
float temperature = 0.0;
float humidity = 0.0;

// History for 24h graph (sample every 10 min = 144 points)
#define HISTORY_SIZE 144
#define SAMPLE_INTERVAL_MS 600000  // 10 minutes in ms

uint16_t co2_history[HISTORY_SIZE];
int16_t temp_history[HISTORY_SIZE];    // Store as temp*10 for 0.1C precision
uint8_t hum_history[HISTORY_SIZE];     // Store as uint8 (0-100%)
uint16_t press_history[HISTORY_SIZE];  // Store as (pressure - 90000) / 10 for Pa precision
uint8_t history_index = 0;
uint8_t history_count = 0;
unsigned long last_sample_time = 0;
unsigned long last_save_time = 0;
#define SAVE_INTERVAL_MS 600000  // Save to flash every 10 minutes

// Min/Max temperature tracking with timestamps
float temp_min_24h = 999.0;
float temp_max_24h = -999.0;
uint8_t temp_min_hour = 0, temp_min_min = 0;
uint8_t temp_max_hour = 0, temp_max_min = 0;

// Graph area constants
#define GRAPH_X 5
#define GRAPH_Y 100
#define GRAPH_W 125
#define GRAPH_H 60

// Air Quality alarm mode
bool airQualityAlarmArmed = false;
bool airQualityAlarmTriggered = false;
// Thresholds for "bad" air quality:
// CO2: >1500 ppm is considered poor ventilation (ASHRAE recommends <1000 for comfort)
// IAQ: >150 is "moderately polluted" per Bosch BSEC guidelines
#define CO2_ALARM_THRESHOLD 1500    // ppm
#define IAQ_ALARM_THRESHOLD 150     // IAQ index

void saveHistory() {
    prefs.begin("co2hist", false);
    prefs.putBytes("co2", co2_history, sizeof(co2_history));
    prefs.putBytes("temp", temp_history, sizeof(temp_history));
    prefs.putBytes("hum", hum_history, sizeof(hum_history));
    prefs.putBytes("press", press_history, sizeof(press_history));
    prefs.putUChar("idx", history_index);
    prefs.putUChar("cnt", history_count);
    // Save min/max with timestamps
    prefs.putFloat("tmin", temp_min_24h);
    prefs.putFloat("tmax", temp_max_24h);
    prefs.putUChar("tminh", temp_min_hour);
    prefs.putUChar("tminm", temp_min_min);
    prefs.putUChar("tmaxh", temp_max_hour);
    prefs.putUChar("tmaxm", temp_max_min);
    prefs.end();
    Serial.println("History saved to flash");
}

void loadHistory() {
    prefs.begin("co2hist", true);
    prefs.getBytes("co2", co2_history, sizeof(co2_history));
    prefs.getBytes("temp", temp_history, sizeof(temp_history));
    prefs.getBytes("hum", hum_history, sizeof(hum_history));
    prefs.getBytes("press", press_history, sizeof(press_history));
    history_index = prefs.getUChar("idx", 0);
    history_count = prefs.getUChar("cnt", 0);
    // Load min/max with timestamps
    temp_min_24h = prefs.getFloat("tmin", 999.0);
    temp_max_24h = prefs.getFloat("tmax", -999.0);
    temp_min_hour = prefs.getUChar("tminh", 0);
    temp_min_min = prefs.getUChar("tminm", 0);
    temp_max_hour = prefs.getUChar("tmaxh", 0);
    temp_max_min = prefs.getUChar("tmaxm", 0);
    prefs.end();
    Serial.printf("History loaded: %d samples\n", history_count);
}

void clearHistory() {
    // Clear RAM data
    memset(co2_history, 0, sizeof(co2_history));
    memset(temp_history, 0, sizeof(temp_history));
    memset(hum_history, 0, sizeof(hum_history));
    memset(press_history, 0, sizeof(press_history));
    history_index = 0;
    history_count = 0;
    
    // Reset min/max
    temp_min_24h = 999.0;
    temp_max_24h = -999.0;
    temp_min_hour = 0;
    temp_min_min = 0;
    temp_max_hour = 0;
    temp_max_min = 0;
    
    // Clear from EEPROM
    prefs.begin("co2hist", false);
    prefs.clear();
    prefs.end();
    
    Serial.println("History cleared from RAM and EEPROM");
}

void addSample() {
    // Use SCD4x data if available, otherwise use ENV Pro data
    float sampleTemp = (scd4xBus != NULL) ? temperature : envProTemperature;
    float sampleHum = (scd4xBus != NULL) ? humidity : envProHumidity;
    
    co2_history[history_index] = co2_value;  // Will be 0 if no CO2 sensor
    temp_history[history_index] = (int16_t)(sampleTemp * 10);
    hum_history[history_index] = (uint8_t)constrain(sampleHum, 0, 100);
    
    // Store pressure: (pressure_Pa - 90000) / 10 to fit in uint16_t
    // This gives range 90000-155535 Pa with 10 Pa resolution
    if (envProInitialized && envProPressure > 0) {
        float pressurePa = envProPressure * 100.0;  // Convert hPa to Pa
        press_history[history_index] = (uint16_t)constrain((pressurePa - 90000) / 10, 0, 65535);
    } else {
        press_history[history_index] = 0;
    }
    
    // Update min/max with current time
    RTC_TimeTypeDef rtcTime;
    M5.Rtc.GetTime(&rtcTime);
    
    if (sampleTemp < temp_min_24h) {
        temp_min_24h = sampleTemp;
        temp_min_hour = rtcTime.Hours;
        temp_min_min = rtcTime.Minutes;
    }
    if (sampleTemp > temp_max_24h) {
        temp_max_24h = sampleTemp;
        temp_max_hour = rtcTime.Hours;
        temp_max_min = rtcTime.Minutes;
    }
    
    history_index = (history_index + 1) % HISTORY_SIZE;
    if (history_count < HISTORY_SIZE) history_count++;
}

// Get weather forecast based on pressure trend over last 3 hours (18 samples at 10 min intervals)
// Returns: 0=unknown, 1=stable, 2=improving (rising), 3=worsening (falling)
uint8_t getWeatherForecast() {
    // Need at least 18 samples (3 hours) for meaningful forecast
    if (history_count < 18) return 0;
    
    // Get oldest sample in our 3-hour window
    int oldestIdx = (history_index - 18 + HISTORY_SIZE) % HISTORY_SIZE;
    uint16_t oldPressEncoded = press_history[oldestIdx];
    
    // Get newest sample (most recent)
    int newestIdx = (history_index - 1 + HISTORY_SIZE) % HISTORY_SIZE;
    uint16_t newPressEncoded = press_history[newestIdx];
    
    // Check if we have valid pressure data
    if (oldPressEncoded == 0 || newPressEncoded == 0) return 0;
    
    // Decode pressure: stored as (pressure_Pa - 90000) / 10
    float oldPressPa = (oldPressEncoded * 10.0) + 90000;
    float newPressPa = (newPressEncoded * 10.0) + 90000;
    
    // Calculate change in Pa over 3 hours
    float pressChange = newPressPa - oldPressPa;
    
    // Thresholds based on meteorological standards:
    // - Change > 100 Pa/3h = significant rising (improving weather)
    // - Change < -100 Pa/3h = significant falling (worsening weather)
    // - Otherwise stable
    if (pressChange > 100) return 2;      // Improving
    else if (pressChange < -100) return 3; // Worsening
    else return 1;                         // Stable
}

const char* getWeatherText(uint8_t forecast) {
    switch (forecast) {
        case 1: return "Stable";
        case 2: return "Improving";
        case 3: return "Worsening";
        default: return "--";
    }
}

uint16_t getWeatherColor(uint8_t forecast) {
    switch (forecast) {
        case 1: return 0x07FF;  // Cyan - stable
        case 2: return GREEN;   // Green - improving
        case 3: return YELLOW;  // Yellow - worsening
        default: return 0x7BEF; // Gray - unknown
    }
}

// ENV Pro BSEC2 callback - called when new data is available
void envProDataCallback(const bme68xData data, const bsecOutputs outputs, Bsec2 bsec) {
    if (!outputs.nOutputs) return;
    
    for (uint8_t i = 0; i < outputs.nOutputs; i++) {
        const bsecData output = outputs.output[i];
        switch (output.sensor_id) {
            case BSEC_OUTPUT_IAQ:
                envProIAQ = output.signal;
                envProIAQAccuracy = output.accuracy;
                break;
            case BSEC_OUTPUT_RAW_TEMPERATURE:
                envProTemperature = output.signal;
                break;
            case BSEC_OUTPUT_RAW_PRESSURE:
                envProPressure = output.signal / 100.0;  // Convert Pa to hPa
                break;
            case BSEC_OUTPUT_RAW_HUMIDITY:
                envProHumidity = output.signal;
                break;
            case BSEC_OUTPUT_RAW_GAS:
                envProGasResistance = output.signal / 1000.0;  // Convert to kOhm
                break;
            case BSEC_OUTPUT_STABILIZATION_STATUS:
                envProStabilized = (output.signal > 0);
                break;
            case BSEC_OUTPUT_RUN_IN_STATUS:
                envProRunIn = (output.signal > 0);
                break;
        }
    }
}

// IAQ levels: 0=Excellent, 1=Good, 2=Moderate, 3=Poor, 4=Unhealthy
uint8_t getIAQLevel(float iaq) {
    if (iaq <= 50) return 0;        // Excellent
    else if (iaq <= 100) return 1;  // Good
    else if (iaq <= 150) return 2;  // Moderate (Lightly polluted)
    else if (iaq <= 200) return 3;  // Poor (Moderately polluted)
    else return 4;                   // Unhealthy (Heavily polluted)
}

const char* getIAQText(uint8_t level) {
    switch(level) {
        case 0: return "Excellent";
        case 1: return "Good";
        case 2: return "Moderate";
        case 3: return "Poor";
        default: return "Unhealthy";
    }
}

// Air quality levels: 0=Good, 1=Moderate, 2=Poor, 3=Bad, 4=Very Bad
uint8_t getCO2Level(uint16_t co2) {
    if (co2 < 800) return 0;       // Good
    else if (co2 < 1000) return 1; // Moderate
    else if (co2 < 1500) return 2; // Poor
    else if (co2 < 2000) return 3; // Bad
    else return 4;                  // Very bad
}

// TVOC levels based on German Federal Environment Agency guidelines
// TVOC in ppb (SGP30 outputs ppb), thresholds converted from mg/m³ (1 mg/m³ ≈ 500 ppb for typical VOC mix)
// Level 1: <0.3 mg/m³ = <150 ppb (Good)
// Level 2: 0.3-1 mg/m³ = 150-500 ppb (Moderate - ventilate)
// Level 3: 1-3 mg/m³ = 500-1500 ppb (Poor - find source)
// Level 4: 3-10 mg/m³ = 1500-5000 ppb (Bad - don't use room)
// Level 5: >10 mg/m³ = >5000 ppb (Very Bad - evacuate)
#define TVOC_ALARM_THRESHOLD 1500  // Level 4: Major consequences
uint8_t getTVOCLevel(uint16_t tvoc_ppb) {
    if (tvoc_ppb < 150) return 0;       // Good - no hygienic consequences
    else if (tvoc_ppb < 500) return 1;  // Moderate - ventilate recommended
    else if (tvoc_ppb < 1500) return 2; // Poor - find contamination source
    else if (tvoc_ppb < 5000) return 3; // Bad - room should not be used
    else return 4;                       // Very Bad - evacuate immediately
}

const char* getTVOCText(uint8_t level) {
    switch(level) {
        case 0: return "Good";
        case 1: return "Ventilate";
        case 2: return "Poor";
        case 3: return "Bad";
        default: return "Evacuate";
    }
}

// Comfort level based on temperature and humidity
uint8_t getComfortLevel(float temp, float hum) {
    // Ideal: 20-24°C, 40-60% humidity
    bool tempOk = (temp >= 18 && temp <= 26);
    bool tempGood = (temp >= 20 && temp <= 24);
    bool humOk = (hum >= 30 && hum <= 70);
    bool humGood = (hum >= 40 && hum <= 60);
    
    if (tempGood && humGood) return 0;       // Good
    if (tempOk && humOk) return 1;           // Moderate
    if ((temp >= 15 && temp <= 30) && (hum >= 20 && hum <= 80)) return 2; // Poor
    if ((temp >= 10 && temp <= 35) && (hum >= 10 && hum <= 90)) return 3; // Bad
    return 4;                                 // Very bad
}

uint16_t getLevelColor(uint8_t level) {
    switch(level) {
        case 0: return GREEN;
        case 1: return YELLOW;
        case 2: return ORANGE;
        case 3: return RED;
        default: return 0xF81F;  // Purple
    }
}

const char* getLevelText(uint8_t level) {
    switch(level) {
        case 0: return "Good";
        case 1: return "Moderate";
        case 2: return "Poor";
        case 3: return "Bad";
        default: return "V.Bad";
    }
}

void getTemp24hMinMax(float &tmin, float &tmax) {
    int16_t imin = 32767;
    int16_t imax = -32768;
    if (history_count == 0) {
        tmin = tmax = temperature;
        return;
    }
    for (int i = 0; i < history_count; i++) {
        int idx = (history_index - history_count + i + HISTORY_SIZE) % HISTORY_SIZE;
        if (temp_history[idx] < imin) imin = temp_history[idx];
        if (temp_history[idx] > imax) imax = temp_history[idx];
    }
    tmin = imin / 10.0;
    tmax = imax / 10.0;
}

// Graph colors - consistent with data display
#define COLOR_CO2 MAGENTA
#define COLOR_TEMP YELLOW
#define COLOR_TEMP_MIN 0xFFE0    // Light yellow (for min temp)
#define COLOR_TEMP_MAX 0xFD20    // Dark yellow/orange-ish (for max temp)
#define COLOR_HUMIDITY CYAN
#define COLOR_PRESSURE 0xFD20    // Orange

void drawGraph(int graphY) {
    // Draw graph border
    tftSprite.drawRect(GRAPH_X, graphY, GRAPH_W, GRAPH_H, WHITE);
    
    // Draw time labels on x-axis
    tftSprite.setTextColor(WHITE);
    // Calculate total time span based on sample interval
    int total_minutes = (HISTORY_SIZE * SAMPLE_INTERVAL_MS) / 60000;
    if (total_minutes >= 60) {
        int hours = total_minutes / 60;
        tftSprite.drawString("-" + String(hours) + "h", GRAPH_X, graphY + GRAPH_H + 2);
        tftSprite.drawString("-" + String(hours/2) + "h", GRAPH_X + GRAPH_W/2 - 8, graphY + GRAPH_H + 2);
    } else {
        tftSprite.drawString("-" + String(total_minutes) + "m", GRAPH_X, graphY + GRAPH_H + 2);
        tftSprite.drawString("-" + String(total_minutes/2) + "m", GRAPH_X + GRAPH_W/2 - 8, graphY + GRAPH_H + 2);
    }
    tftSprite.drawString("now", GRAPH_X + GRAPH_W - 18, graphY + GRAPH_H + 2);
    
    if (history_count < 2) return;
    
    // Find min/max for scaling
    uint16_t co2_min = 400, co2_max = 2000;
    int16_t temp_min = -100, temp_max = 400;  // *10 for 0.1C precision
    uint8_t hum_min = 0, hum_max = 100;
    uint16_t press_min = 0, press_max = 6553;  // Encoded: (Pa - 90000) / 10
    
    // Draw the 4 lines (right-aligned to "now")
    int x_offset = HISTORY_SIZE - history_count;  // Offset to align newest data to right edge
    for (int i = 1; i < history_count; i++) {
        int prev_idx = (history_index - history_count + i - 1 + HISTORY_SIZE) % HISTORY_SIZE;
        int curr_idx = (history_index - history_count + i + HISTORY_SIZE) % HISTORY_SIZE;
        
        int x1 = GRAPH_X + 1 + ((x_offset + i - 1) * (GRAPH_W - 2)) / (HISTORY_SIZE - 1);
        int x2 = GRAPH_X + 1 + ((x_offset + i) * (GRAPH_W - 2)) / (HISTORY_SIZE - 1);
        
        // CO2 line (magenta) - only if CO2 sensor present
        if (scd4xBus != NULL) {
            int y1_co2 = graphY + GRAPH_H - 2 - map(constrain(co2_history[prev_idx], co2_min, co2_max), co2_min, co2_max, 0, GRAPH_H - 4);
            int y2_co2 = graphY + GRAPH_H - 2 - map(constrain(co2_history[curr_idx], co2_min, co2_max), co2_min, co2_max, 0, GRAPH_H - 4);
            tftSprite.drawLine(x1, y1_co2, x2, y2_co2, COLOR_CO2);
        }
        
        // Temperature line (yellow)
        int y1_temp = graphY + GRAPH_H - 2 - map(constrain(temp_history[prev_idx], temp_min, temp_max), temp_min, temp_max, 0, GRAPH_H - 4);
        int y2_temp = graphY + GRAPH_H - 2 - map(constrain(temp_history[curr_idx], temp_min, temp_max), temp_min, temp_max, 0, GRAPH_H - 4);
        tftSprite.drawLine(x1, y1_temp, x2, y2_temp, COLOR_TEMP);
        
        // Humidity line (cyan)
        int y1_hum = graphY + GRAPH_H - 2 - map(constrain(hum_history[prev_idx], hum_min, hum_max), hum_min, hum_max, 0, GRAPH_H - 4);
        int y2_hum = graphY + GRAPH_H - 2 - map(constrain(hum_history[curr_idx], hum_min, hum_max), hum_min, hum_max, 0, GRAPH_H - 4);
        tftSprite.drawLine(x1, y1_hum, x2, y2_hum, COLOR_HUMIDITY);
        
        // Pressure line (orange) - only if ENV Pro present and has valid data
        if (envProInitialized && press_history[prev_idx] > 0 && press_history[curr_idx] > 0) {
            int y1_press = graphY + GRAPH_H - 2 - map(constrain(press_history[prev_idx], press_min, press_max), press_min, press_max, 0, GRAPH_H - 4);
            int y2_press = graphY + GRAPH_H - 2 - map(constrain(press_history[curr_idx], press_min, press_max), press_min, press_max, 0, GRAPH_H - 4);
            tftSprite.drawLine(x1, y1_press, x2, y2_press, COLOR_PRESSURE);
        }
    }
}

// Buzzer on GPIO 2
#define BUZZER_PIN 2
#define BUZZER_CHANNEL 0

// Internal LED on GPIO 10 (active LOW)
#define LED_PIN 10

// Star Wars Imperial March
// Format: note, duration, note, duration, ...
// Duration: 4 = quarter note, 8 = eighth note, 2 = half note, etc.
// Negative duration = dotted note (1.5x duration)
const int16_t alarmMelody[] = {
    NOTE_B4, 16, NOTE_B5, 16, NOTE_FS5, 16, NOTE_DS5, 16, //1
    NOTE_B5, 32, NOTE_FS5, -16, NOTE_DS5, 8, NOTE_C5, 16,
    NOTE_C6, 16, NOTE_G6, 16, NOTE_E6, 16, NOTE_C6, 32, NOTE_G6, -16, NOTE_E6, 8,

    NOTE_B4, 16,  NOTE_B5, 16,  NOTE_FS5, 16,   NOTE_DS5, 16,  NOTE_B5, 32,  //2
    NOTE_FS5, -16, NOTE_DS5, 8,  NOTE_DS5, 32, NOTE_E5, 32,  NOTE_F5, 32,
    NOTE_F5, 32,  NOTE_FS5, 32,  NOTE_G5, 32,  NOTE_G5, 32, NOTE_GS5, 32,  NOTE_A5, 16, NOTE_B5, 8
};
const int alarmMelodyNotes = sizeof(alarmMelody) / sizeof(alarmMelody[0]) / 2;  // Number of notes (pairs)
int alarmTempo = 120;  // BPM - adjust this to change melody speed
unsigned long currentNoteDuration = 0;

void buzzerTone(uint16_t freq) {
    if (freq > 0) {
        ledcWriteTone(BUZZER_PIN, freq);
    } else {
        ledcWriteTone(BUZZER_PIN, 0);
    }
}

void buzzerMute() {
    ledcWriteTone(BUZZER_PIN, 0);
}

void buzzerInit() {
    ledcAttach(BUZZER_PIN, 5000, 8);
}

void playAlarmTick() {
    unsigned long now = millis();
    if (now - lastAlarmTone >= currentNoteDuration) {
        // Get note and duration from melody array
        int16_t note = alarmMelody[alarmToneIndex * 2];
        int16_t divider = alarmMelody[alarmToneIndex * 2 + 1];
        
        // Calculate note duration based on tempo
        // wholenote = (60000 * 4) / tempo (duration of a whole note in ms)
        int wholenote = (60000 * 4) / alarmTempo;
        
        if (divider > 0) {
            // Regular note
            currentNoteDuration = wholenote / divider;
        } else if (divider < 0) {
            // Dotted note: duration * 1.5
            currentNoteDuration = (wholenote / abs(divider)) * 1.5;
        }
        
        // Play the note (REST = 0 will be silent)
        buzzerTone(note);
        
        alarmToneIndex = (alarmToneIndex + 1) % alarmMelodyNotes;
        lastAlarmTone = now;
    }
}

void stopAlarm() {
    buzzerMute();
    alarmToneIndex = 0;
    currentNoteDuration = 0;
    digitalWrite(LED_PIN, HIGH);  // Turn off LED (active LOW)
}

// LED functions
void ledInit() {
    pinMode(LED_PIN, OUTPUT);
    digitalWrite(LED_PIN, HIGH);  // OFF (active LOW)
}

void ledOn() {
    digitalWrite(LED_PIN, LOW);  // ON (active LOW)
}

void ledOff() {
    digitalWrite(LED_PIN, HIGH);  // OFF (active LOW)
}

// Combined alarm trigger - plays sound and flashes LED
bool alarmLedState = false;
unsigned long lastAlarmLedToggle = 0;
#define ALARM_LED_INTERVAL 200  // LED flash interval in ms

// Forward declarations for Home Assistant trigger
void haTriggerAlarm(const char* source);
void haResetTrigger();

void triggerAlarm() {
    // Play melody
    playAlarmTick();
    
    // Flash LED
    unsigned long now = millis();
    if (now - lastAlarmLedToggle >= ALARM_LED_INTERVAL) {
        alarmLedState = !alarmLedState;
        if (alarmLedState) {
            ledOn();
        } else {
            ledOff();
        }
        lastAlarmLedToggle = now;
    }
    
}

void drawBatteryIcon(int x, int y, float batteryPct) {
    // Battery outline (12x7 pixels)
    tftSprite.drawRect(x, y, 12, 7, WHITE);
    tftSprite.fillRect(x + 12, y + 2, 2, 3, WHITE);  // Battery tip
    
    // Fill bars based on percentage (3 bars)
    uint16_t barColor;
    if (batteryPct > 60) barColor = GREEN;
    else if (batteryPct > 20) barColor = YELLOW;
    else barColor = RED;
    
    int bars = (batteryPct > 66) ? 3 : (batteryPct > 33) ? 2 : (batteryPct > 5) ? 1 : 0;
    for (int i = 0; i < bars; i++) {
        tftSprite.fillRect(x + 1 + i * 4, y + 1, 3, 5, barColor);
    }
}

void drawChargingIcon(int x, int y) {
    tftSprite.setTextColor(YELLOW);
    tftSprite.setCursor(x, y);
    tftSprite.print("+");
}

void drawBluetoothIcon(int x, int y) {
    // Draw simple Bluetooth icon (8x10 pixels)
    tftSprite.drawLine(x + 4, y, x + 4, y + 9, BLUE);      // Vertical line
    tftSprite.drawLine(x + 4, y, x + 7, y + 3, BLUE);      // Top right diagonal
    tftSprite.drawLine(x + 7, y + 3, x + 1, y + 7, BLUE);  // Right to left diagonal
    tftSprite.drawLine(x + 1, y + 2, x + 7, y + 6, BLUE);  // Left to right diagonal
    tftSprite.drawLine(x + 7, y + 6, x + 4, y + 9, BLUE);  // Bottom right diagonal
}

void drawHeader() {
    RTC_TimeTypeDef rtcTime;
    RTC_DateTypeDef rtcDate;
    M5.Rtc.GetTime(&rtcTime);
    M5.Rtc.GetDate(&rtcDate);
    
    // Get battery info
    float batteryVoltage = M5.Axp.GetBatVoltage();
    float batteryPct = (batteryVoltage - 3.0) / (4.2 - 3.0) * 100.0;
    if (batteryPct > 100) batteryPct = 100;
    if (batteryPct < 0) batteryPct = 0;
    
    // Check if charging (USB power connected)
    bool isCharging = M5.Axp.GetVBusVoltage() > 4.0;
    
    // Estimate remaining time (rough: 120mAh battery, ~40mA avg consumption)
    float batteryMah = 120.0 * (batteryPct / 100.0);
    int remainingMins = (int)(batteryMah / 40.0 * 60.0);
    int remainingHrs = remainingMins / 60;
    remainingMins = remainingMins % 60;
    
    // Draw time and date (HH:MM MM/DD format)
    tftSprite.setTextColor(WHITE);
    tftSprite.setCursor(2, 3);
    tftSprite.printf("%02d:%02d %02d/%02d", rtcTime.Hours, rtcTime.Minutes, rtcDate.Month, rtcDate.Date);
    
    // Draw remaining time estimate (when not charging)
    if (!isCharging && batteryPct < 100) {
        tftSprite.setTextColor(0x7BEF);
        tftSprite.setCursor(70, 3);
        tftSprite.printf("%dh%02d", remainingHrs, remainingMins);
    }
    
    // Dynamic right-aligned icons: [WiFi W] [Charging +] [Battery]
    // Calculate positions from right to left
    const int rightMargin = 135;
    const int iconY = 3;
    const int batteryWidth = 14;   // 12 + 2 for tip
    const int chargingWidth = 8;   // "+" character width
    const int wifiWidth = 8;       // "W" character width
    const int iconSpacing = 2;     // Space between icons
    
    int xPos = rightMargin - batteryWidth;  // Start with battery at far right
    
    // Draw battery icon (always shown)
    drawBatteryIcon(xPos, iconY, batteryPct);
    xPos -= iconSpacing;
    
    // Draw charging icon if charging
    if (isCharging) {
        xPos -= chargingWidth;
        drawChargingIcon(xPos, iconY - 1);
        xPos -= iconSpacing;
    }
    
    // Draw WiFi icon if connected (Home Assistant app)
    if (haState == HA_CONNECTED || haState == HA_SENDING || haState == HA_SUCCESS) {
        xPos -= wifiWidth;
        tftSprite.setTextColor(BLUE);
        tftSprite.setCursor(xPos, iconY);
        tftSprite.print("W");
        xPos -= iconSpacing;
    }
    
    tftSprite.drawLine(0, 14, 135, 14, 0x7BEF);
}

void app_air_quality() {
    tftSprite.fillRect(0, 0, 135, 240, BLACK);
    drawHeader();
    
    int yPos = 18;  // Starting Y position for content
    
    // Check alarm conditions first (for label coloring)
    bool co2AlarmActive = (scd4xBus != NULL && co2_value > CO2_ALARM_THRESHOLD);
    bool sgp30AlarmActive = (sgp30Initialized && sgp30eCO2 > CO2_ALARM_THRESHOLD);
    bool iaqAlarmActive = (envProInitialized && envProIAQAccuracy >= 1 && envProIAQ > IAQ_ALARM_THRESHOLD);
    
    // Display CO2 sensor values (prefer SCD4x over SGP30 eCO2)
    if (scd4xBus != NULL) {
        // SCD4x real CO2 sensor - preferred
        uint8_t co2Level = getCO2Level(co2_value);
        tftSprite.setTextColor((airQualityAlarmTriggered && co2AlarmActive) ? RED : WHITE);
        tftSprite.drawString("CO2:", 5, yPos);
        tftSprite.setTextColor(COLOR_CO2);  // Magenta - matches graph
        tftSprite.setCursor(35, yPos);
        tftSprite.printf("%d ", co2_value);
        tftSprite.setTextColor(getLevelColor(co2Level));
        tftSprite.print(getLevelText(co2Level));
        yPos += 11;
    } else if (sgp30Initialized) {
        // SGP30 eCO2 (estimated) - fallback when no real CO2 sensor
        uint8_t co2Level = getCO2Level(sgp30eCO2);
        tftSprite.setTextColor((airQualityAlarmTriggered && sgp30AlarmActive) ? RED : WHITE);
        tftSprite.drawString("eCO2:", 5, yPos);
        tftSprite.setTextColor(COLOR_CO2);  // Magenta - matches graph
        tftSprite.setCursor(40, yPos);
        tftSprite.printf("%d ", sgp30eCO2);
        tftSprite.setTextColor(getLevelColor(co2Level));
        tftSprite.print(getLevelText(co2Level));
        yPos += 11;
    }
    
    // Display TVOC from SGP30 (if detected) - gray, not in graph
    if (sgp30Initialized) {
        uint8_t tvocLevel = getTVOCLevel(sgp30TVOC);
        bool tvocAlarmActive = (sgp30TVOC >= TVOC_ALARM_THRESHOLD);
        tftSprite.setTextColor((airQualityAlarmTriggered && tvocAlarmActive) ? RED : WHITE);
        tftSprite.drawString("TVOC:", 5, yPos);
        tftSprite.setTextColor(0x7BEF);  // Gray - not in graph
        tftSprite.setCursor(40, yPos);
        tftSprite.printf("%d ", sgp30TVOC);
        tftSprite.setTextColor(getLevelColor(tvocLevel));
        tftSprite.print(getTVOCText(tvocLevel));
        yPos += 11;
    }
    
    // Display ENV Pro IAQ (if detected) - gray, not in graph
    if (envProInitialized) {
        uint8_t iaqLevel = getIAQLevel(envProIAQ);
        // Label color: red if alarm triggered, white otherwise
        tftSprite.setTextColor((airQualityAlarmTriggered && iaqAlarmActive) ? RED : WHITE);
        tftSprite.drawString("IAQ:", 5, yPos);
        tftSprite.setTextColor(0x7BEF);  // Gray - not in graph
        tftSprite.setCursor(35, yPos);
        tftSprite.printf("%.0f ", envProIAQ);
        tftSprite.setTextColor(getLevelColor(iaqLevel));
        tftSprite.print(getIAQText(iaqLevel));
        // Show accuracy indicator
        if (envProIAQAccuracy < 3) {
            tftSprite.setTextColor(0x7BEF);
            tftSprite.printf(" *%d", envProIAQAccuracy);
        }
        yPos += 11;
    }
    
    // Temperature - prefer SCD4x if available, else ENV Pro
    float displayTemp = (scd4xBus != NULL) ? temperature : envProTemperature;
    tftSprite.setTextColor(WHITE);
    tftSprite.drawString("Temp:", 5, yPos);
    tftSprite.setTextColor(COLOR_TEMP);  // Yellow - matches graph
    tftSprite.setCursor(40, yPos);
    tftSprite.printf("%.1f C", displayTemp);
    yPos += 11;
    
    // Min temp with time - light yellow
    tftSprite.setTextColor(WHITE);
    tftSprite.drawString("Min:", 5, yPos);
    tftSprite.setTextColor(COLOR_TEMP_MIN);  // Light yellow
    tftSprite.setCursor(30, yPos);
    if (temp_min_24h < 900) {
        tftSprite.printf("%.1f @%02d:%02d", temp_min_24h, temp_min_hour, temp_min_min);
    } else {
        tftSprite.printf("--.-");
    }
    yPos += 11;
    
    // Max temp with time - dark yellow/orange
    tftSprite.setTextColor(WHITE);
    tftSprite.drawString("Max:", 5, yPos);
    tftSprite.setTextColor(COLOR_TEMP_MAX);  // Dark yellow
    tftSprite.setCursor(30, yPos);
    if (temp_max_24h > -900) {
        tftSprite.printf("%.1f @%02d:%02d", temp_max_24h, temp_max_hour, temp_max_min);
    } else {
        tftSprite.printf("--.-");
    }
    yPos += 11;
    
    // Humidity - prefer SCD4x if available, else ENV Pro
    float displayHum = (scd4xBus != NULL) ? humidity : envProHumidity;
    uint8_t comfortLevel = getComfortLevel(displayTemp, displayHum);
    tftSprite.setTextColor(WHITE);
    tftSprite.drawString("Hum:", 5, yPos);
    tftSprite.setTextColor(COLOR_HUMIDITY);  // Cyan - matches graph
    tftSprite.setCursor(35, yPos);
    tftSprite.printf("%.0f%% ", displayHum);
    tftSprite.setTextColor(getLevelColor(comfortLevel));
    tftSprite.print(getLevelText(comfortLevel));
    yPos += 11;
    
    // ENV Pro additional data: Pressure, Weather forecast, and Gas
    if (envProInitialized) {
        // Pressure in Pa - orange, matches graph
        tftSprite.setTextColor(WHITE);
        tftSprite.drawString("Press:", 5, yPos);
        tftSprite.setTextColor(COLOR_PRESSURE);  // Orange - matches graph
        tftSprite.setCursor(45, yPos);
        tftSprite.printf("%.0f Pa", envProPressure * 100.0);  // Convert hPa to Pa
        yPos += 11;
        
        // Weather forecast based on pressure trend - gray, derived data
        uint8_t forecast = getWeatherForecast();
        tftSprite.setTextColor(WHITE);
        tftSprite.drawString("Trend:", 5, yPos);
        tftSprite.setTextColor(getWeatherColor(forecast));
        tftSprite.setCursor(45, yPos);
        tftSprite.print(getWeatherText(forecast));
        yPos += 11;
        
        // Gas resistance - gray, not in graph
        tftSprite.setTextColor(WHITE);
        tftSprite.drawString("Gas:", 5, yPos);
        tftSprite.setTextColor(0x7BEF);  // Gray - not in graph
        tftSprite.setCursor(35, yPos);
        tftSprite.printf("%.1f kOhm", envProGasResistance);
        yPos += 11;
    }
    
    // Check alarm condition and trigger if armed
    bool airQualityBad = false;
    if (scd4xBus != NULL && co2_value > CO2_ALARM_THRESHOLD) {
        airQualityBad = true;
    }
    if (sgp30Initialized && sgp30eCO2 > CO2_ALARM_THRESHOLD) {
        airQualityBad = true;
    }
    if (sgp30Initialized && sgp30TVOC >= TVOC_ALARM_THRESHOLD) {
        airQualityBad = true;
    }
    if (envProInitialized && envProIAQAccuracy >= 1 && envProIAQ > IAQ_ALARM_THRESHOLD) {
        airQualityBad = true;
    }
    
    if (airQualityAlarmArmed) {
        if (airQualityBad && !airQualityAlarmTriggered) {
            airQualityAlarmTriggered = true;
            haTriggerAlarm("air_quality");
        }
        if (airQualityAlarmTriggered) {
            triggerAlarm();
        }
        // Stop alarm if air quality is good again
        if (!airQualityBad && airQualityAlarmTriggered) {
            airQualityAlarmTriggered = false;
            stopAlarm();
            haResetTrigger();
        }
    }
    
    // Draw 24h graph if we have any sensor data (CO2 or ENV Pro)
    if (scd4xBus != NULL || envProInitialized) {
        yPos += 2;  // Small gap before graph
        drawGraph(yPos);
        yPos += GRAPH_H + 14;  // Graph height + labels
    }
    
    // Alarm status display (below graph)
    if (airQualityAlarmArmed) {
        if (airQualityAlarmTriggered) {
            tftSprite.setTextColor(RED);
            tftSprite.drawString("!! BAD AIR !!", 5, yPos);
        } else {
            tftSprite.setTextColor(GREEN);
            tftSprite.drawString("ALARM ARMED", 5, yPos);
        }
    } else {
        tftSprite.setTextColor(0x7BEF);
        tftSprite.drawString("[A] Arm Alarm", 5, yPos);
    }
    yPos += 13;
    
    // Hint at bottom (dynamic position)
    tftSprite.setTextColor(0x7BEF);
    tftSprite.drawString("[HOLD A] Menu", 5, yPos);
    yPos += 13;
    tftSprite.drawString("[HOLD B] Clear", 5, yPos);
    
    tftSprite.pushSprite(0, 0);
}

void app_stopwatch() {
    tftSprite.fillRect(0, 0, 135, 240, BLACK);
    drawHeader();
    
    // Title
    tftSprite.setTextColor(CYAN);
    tftSprite.drawString("STOPWATCH", 40, 20);
    
    // Calculate display time
    unsigned long displayTime = stopwatchElapsed;
    if (stopwatchRunning) {
        displayTime = millis() - stopwatchStartTime + stopwatchElapsed;
    }
    
    unsigned long totalSecs = displayTime / 1000;
    unsigned long hours = totalSecs / 3600;
    unsigned long mins = (totalSecs % 3600) / 60;
    unsigned long secs = totalSecs % 60;
    unsigned long ms = (displayTime % 1000) / 10;
    
    // Large time display
    tftSprite.setTextSize(2);
    tftSprite.setTextColor(WHITE);
    tftSprite.setCursor(10, 60);
    tftSprite.printf("%02lu:%02lu:%02lu", hours, mins, secs);
    tftSprite.setTextSize(1);
    tftSprite.setCursor(100, 70);
    tftSprite.printf(".%02lu", ms);
    
    // Status
    tftSprite.setCursor(40, 100);
    if (stopwatchRunning) {
        tftSprite.setTextColor(GREEN);
        tftSprite.print("RUNNING");
    } else if (displayTime > 0) {
        tftSprite.setTextColor(YELLOW);
        tftSprite.print("PAUSED");
    } else {
        tftSprite.setTextColor(0x7BEF);
        tftSprite.print("STOPPED");
    }
    
    // Controls hint
    tftSprite.setTextColor(0x7BEF);
    tftSprite.drawString("[PRESS] Start/Stop", 20, 130);
    tftSprite.drawString("[SIDE] Reset", 35, 145);
    tftSprite.drawString("[HOLD] Menu", 35, 180);
    
    tftSprite.pushSprite(0, 0);
}

void app_timer() {
    tftSprite.fillRect(0, 0, 135, 240, BLACK);
    drawHeader();
    
    // Title
    tftSprite.setTextColor(CYAN);
    tftSprite.drawString("TIMER", 50, 20);
    
    // Calculate display time
    unsigned long displayTime = 0;
    if (timerState == TIMER_SETTING) {
        displayTime = timerDuration;
    } else if (timerState == TIMER_RUNNING) {
        unsigned long elapsed = millis() - timerStartTime;
        displayTime = (elapsed >= timerRemaining) ? 0 : timerRemaining - elapsed;
    } else if (timerState == TIMER_PAUSED) {
        displayTime = timerRemaining;
    } else {  // TIMER_FINISHED
        displayTime = 0;
    }
    
    unsigned long totalSecs = displayTime / 1000;
    unsigned long hours = totalSecs / 3600;
    unsigned long mins = (totalSecs % 3600) / 60;
    unsigned long secs = totalSecs % 60;
    
    // Large time display
    tftSprite.setTextSize(2);
    if (timerState == TIMER_FINISHED) {
        tftSprite.setTextColor(RED);
    } else if (timerState == TIMER_SETTING) {
        tftSprite.setTextColor(YELLOW);
    } else {
        tftSprite.setTextColor(WHITE);
    }
    tftSprite.setCursor(10, 60);
    tftSprite.printf("%02lu:%02lu:%02lu", hours, mins, secs);
    tftSprite.setTextSize(1);
    
    // Status
    tftSprite.setCursor(40, 100);
    switch (timerState) {
        case TIMER_SETTING:
            tftSprite.setTextColor(YELLOW);
            tftSprite.print("SET TIME");
            break;
        case TIMER_RUNNING:
            tftSprite.setTextColor(GREEN);
            tftSprite.print("RUNNING");
            break;
        case TIMER_PAUSED:
            tftSprite.setTextColor(YELLOW);
            tftSprite.print("PAUSED");
            break;
        case TIMER_FINISHED:
            tftSprite.setTextColor(RED);
            tftSprite.print("FINISHED!");
            break;
    }
    
    // Controls hint
    tftSprite.setTextColor(0x7BEF);
    if (timerState == TIMER_SETTING) {
        tftSprite.drawString("[ENC/SIDE] Set time", 15, 130);
        tftSprite.drawString("[PRESS] Start", 30, 145);
    } else if (timerState == TIMER_FINISHED) {
        tftSprite.drawString("[PRESS] Reset", 30, 130);
    } else {
        tftSprite.drawString("[PRESS] Start/Stop", 20, 130);
        tftSprite.drawString("[SIDE] Reset", 35, 145);
    }
    tftSprite.drawString("[HOLD] Menu", 35, 180);
    
    tftSprite.pushSprite(0, 0);
}

void app_motion() {
    tftSprite.fillRect(0, 0, 135, 240, BLACK);
    drawHeader();
    
    // Title
    tftSprite.setTextColor(CYAN);
    tftSprite.drawString("MOTION ALARM", 30, 20);
    
    // Read PIR sensor
    bool pirState = digitalRead(PIR_PIN);
    
    // Large status display
    tftSprite.setTextSize(2);
    if (motionArmed) {
        if (pirState) {
            motionDetected = true;
            lastMotionTime = millis();
            tftSprite.setTextColor(RED);
            tftSprite.setCursor(15, 60);
            tftSprite.print("MOTION!");
        } else if (motionDetected && millis() - lastMotionTime < 3000) {
            // Keep showing motion for 3 seconds
            tftSprite.setTextColor(RED);
            tftSprite.setCursor(15, 60);
            tftSprite.print("MOTION!");
        } else {
            motionDetected = false;
            tftSprite.setTextColor(GREEN);
            tftSprite.setCursor(15, 60);
            tftSprite.print("CLEAR");
        }
    } else {
        tftSprite.setTextColor(YELLOW);
        tftSprite.setCursor(10, 60);
        tftSprite.print("DISARMED");
    }
    tftSprite.setTextSize(1);
    
    // Status
    tftSprite.setCursor(30, 105);
    if (motionArmed) {
        tftSprite.setTextColor(GREEN);
        tftSprite.print("Alarm Armed");
    } else {
        tftSprite.setTextColor(0x7BEF);
        tftSprite.print("Alarm Disarmed");
    }
    
    // PIR raw state
    tftSprite.setTextColor(0x7BEF);
    tftSprite.setCursor(35, 120);
    tftSprite.printf("PIR: %s", pirState ? "HIGH" : "LOW");
    
    // Controls hint
    tftSprite.setTextColor(0x7BEF);
    tftSprite.drawString("[PRESS] Arm/Disarm", 15, 145);
    tftSprite.drawString("[HOLD] Menu", 35, 180);
    
    tftSprite.pushSprite(0, 0);
}

void app_ncir() {
    tftSprite.fillRect(0, 0, 135, 240, BLACK);
    drawHeader();
    
    // Title
    tftSprite.setTextColor(CYAN);
    tftSprite.drawString("NCIR TEMP", 35, 20);
    
    // Switch to Grove if sensor is on Grove port
    if (mlxBus == &Wire1) switchWire1ToGrove();
    
    // Read temperatures from MLX90614
    float objectTemp = mlx.readObjectTempC();
    float ambientTemp = mlx.readAmbientTempC();
    
    // Restore Wire1 to internal for AXP192/RTC
    if (mlxBus == &Wire1) switchWire1ToInternal();
    
    // Object temperature (large display)
    tftSprite.setTextSize(2);
    if (objectTemp > 37.5) {
        tftSprite.setTextColor(RED);  // Fever warning
    } else if (objectTemp > 35.0) {
        tftSprite.setTextColor(GREEN);  // Normal body temp
    } else {
        tftSprite.setTextColor(CYAN);  // Cool/object temp
    }
    tftSprite.setCursor(10, 55);
    tftSprite.printf("%.1f", objectTemp);
    tftSprite.setTextSize(1);
    tftSprite.print(" C");
    
    // Label
    tftSprite.setTextColor(0x7BEF);
    tftSprite.setCursor(30, 90);
    tftSprite.print("Object Temp");
    
    // Ambient temperature
    tftSprite.setTextColor(YELLOW);
    tftSprite.setCursor(25, 115);
    tftSprite.printf("Ambient: %.1f C", ambientTemp);
    
    // Temperature bar visualization (-70 to 382.2°C range)
    // Map to bar width: -70 to 400 range for display
    int barWidth = map(constrain((int)(objectTemp), -70, 400), -70, 400, 0, 100);
    tftSprite.drawRect(17, 140, 104, 12, 0x7BEF);
    uint16_t barColor;
    if (objectTemp > 100) {
        barColor = RED;  // Very hot
    } else if (objectTemp > 37.5) {
        barColor = ORANGE;  // Hot/fever
    } else if (objectTemp > 35.0) {
        barColor = GREEN;  // Normal body temp
    } else if (objectTemp > 0) {
        barColor = CYAN;  // Cool
    } else {
        barColor = BLUE;  // Below freezing
    }
    tftSprite.fillRect(18, 141, barWidth, 10, barColor);
    
    // Scale labels
    tftSprite.setTextColor(0x7BEF);
    tftSprite.setCursor(5, 155);
    tftSprite.print("-70");
    tftSprite.setCursor(105, 155);
    tftSprite.print("400C");
    
    // Controls hint
    tftSprite.drawString("[HOLD] Menu", 35, 180);
    
    tftSprite.pushSprite(0, 0);
}

void app_heartrate() {
    tftSprite.fillRect(0, 0, 135, 240, BLACK);
    drawHeader();
    
    // Title
    tftSprite.setTextColor(CYAN);
    tftSprite.drawString("HEART RATE", 35, 20);
    
    static long lastIrValue = 0;
    static int sampleCount = 0;
    static bool hrInitialized = false;
    
    // Switch to Grove if sensor is on Grove port
    if (heartRateBus == &Wire1) switchWire1ToGrove();
    
    // Initialize sensor on first entry to this app
    if (!hrInitialized) {
        // Re-initialize sensor with specific settings for heart rate
        heartRateSensor.softReset();
        delay(100);
        heartRateSensor.setup(0x1F, 4, 2, 400, 411, 4096);  // Higher brightness, faster sample rate
        hrInitialized = true;
        Serial.println("HR sensor initialized");
    }
    
    // Use safeCheck which blocks until data is available (with timeout)
    byte available = heartRateSensor.safeCheck(100);  // 100ms timeout
    
    // Read samples
    while (available > 0) {
        long irValue = heartRateSensor.getFIFOIR();
        long redValue = heartRateSensor.getFIFORed();
        lastIrValue = irValue;
        sampleCount++;
        available--;
        
        fingerDetected = (irValue > 50000);
        
        if (fingerDetected) {
            // Custom beat detection using signal derivative
            hrIrDelta = irValue - hrIrPrev;
            hrIrPrev = irValue;
            
            // Detect beat: look for transition from rising to falling (peak)
            // hrIrDeltaPrev > threshold and hrIrDelta < -threshold indicates a peak
            if (hrIrDeltaPrev > 100 && hrIrDelta < -100 && !hrBeatState) {
                hrBeatState = true;
                long delta = millis() - hrLastBeat;
                hrLastBeat = millis();
                
                // Valid beat interval: 300-1500ms (40-200 BPM)
                if (delta > 300 && delta < 1500) {
                    float bpm = 60000.0 / delta;
                    
                    if (bpm > 40 && bpm < 200) {
                        heartBPM = (int32_t)bpm;
                        hrRates[hrRateSpot++] = (byte)bpm;
                        hrRateSpot %= HR_RATE_SIZE;
                        if (hrValidReadings < HR_RATE_SIZE) hrValidReadings++;
                        
                        // Calculate average only from valid readings
                        heartBPMAvg = 0;
                        for (byte x = 0; x < hrValidReadings; x++) {
                            heartBPMAvg += hrRates[x];
                        }
                        heartBPMAvg /= hrValidReadings;
                    }
                }
            }
            
            // Reset beat state when signal is falling significantly
            if (hrIrDelta < -50) {
                hrBeatState = false;
            }
            
            hrIrDeltaPrev = hrIrDelta;
        } else {
            // Reset when finger removed
            hrValidReadings = 0;
            heartBPMAvg = 0;
            heartBPM = 0;
            hrIrPrev = 0;
            hrIrDelta = 0;
            hrIrDeltaPrev = 0;
            hrBeatState = false;
        }
    }
    
    // Record history sample every 5 minutes if we have a valid reading
    if (heartBPMAvg > 0 && millis() - hr_last_sample_time >= HR_SAMPLE_INTERVAL_MS) {
        hr_history[hr_history_index] = (uint8_t)heartBPMAvg;
        hr_history_index = (hr_history_index + 1) % HR_HISTORY_SIZE;
        if (hr_history_count < HR_HISTORY_SIZE) hr_history_count++;
        hr_last_sample_time = millis();
        
        // Update min/max with timestamps
        RTC_TimeTypeDef rtcTime;
        M5.Rtc.GetTime(&rtcTime);
        
        if (heartBPMAvg < hr_min_12h) {
            hr_min_12h = heartBPMAvg;
            hr_min_hour = rtcTime.Hours;
            hr_min_min = rtcTime.Minutes;
        }
        if (heartBPMAvg > hr_max_12h) {
            hr_max_12h = heartBPMAvg;
            hr_max_hour = rtcTime.Hours;
            hr_max_min = rtcTime.Minutes;
        }
    }
    
    // Large BPM display
    tftSprite.setTextSize(2);
    if (fingerDetected) {
        if (heartBPMAvg > 100) {
            tftSprite.setTextColor(RED);
        } else if (heartBPMAvg > 60) {
            tftSprite.setTextColor(GREEN);
        } else if (heartBPMAvg > 0) {
            tftSprite.setTextColor(YELLOW);
        } else {
            tftSprite.setTextColor(CYAN);
        }
        tftSprite.setCursor(30, 40);
        if (heartBPMAvg > 0) {
            tftSprite.printf("%d", heartBPMAvg);
        } else {
            tftSprite.print("--");
        }
        tftSprite.setTextSize(1);
        tftSprite.print(" BPM");
    } else {
        tftSprite.setTextColor(RED);
        tftSprite.setCursor(10, 45);
        tftSprite.print("NO FINGER");
    }
    tftSprite.setTextSize(1);
    
    // Min/Max display
    tftSprite.setTextColor(0x7BEF);
    tftSprite.setCursor(5, 65);
    if (hr_min_12h < 255) {
        tftSprite.printf("Min:%d @%02d:%02d", hr_min_12h, hr_min_hour, hr_min_min);
    }
    tftSprite.setCursor(5, 78);
    if (hr_max_12h > 0) {
        tftSprite.printf("Max:%d @%02d:%02d", hr_max_12h, hr_max_hour, hr_max_min);
    }
    
    // Draw 12h history graph
    const int graphX = 5, graphY = 95, graphW = 125, graphH = 50;
    tftSprite.drawRect(graphX, graphY, graphW, graphH, 0x7BEF);
    
    // Draw graph data if we have history
    if (hr_history_count > 1) {
        // Find min/max for scaling
        uint8_t graphMin = 255, graphMax = 0;
        for (int i = 0; i < hr_history_count; i++) {
            if (hr_history[i] > 0) {
                if (hr_history[i] < graphMin) graphMin = hr_history[i];
                if (hr_history[i] > graphMax) graphMax = hr_history[i];
            }
        }
        
        // Ensure reasonable range
        if (graphMax - graphMin < 20) {
            int mid = (graphMax + graphMin) / 2;
            graphMin = max(40, mid - 10);
            graphMax = min(180, mid + 10);
        }
        
        // Draw graph lines
        for (int i = 1; i < hr_history_count; i++) {
            int idx1 = (hr_history_index - hr_history_count + i - 1 + HR_HISTORY_SIZE) % HR_HISTORY_SIZE;
            int idx2 = (hr_history_index - hr_history_count + i + HR_HISTORY_SIZE) % HR_HISTORY_SIZE;
            
            if (hr_history[idx1] > 0 && hr_history[idx2] > 0) {
                int x1 = graphX + 1 + ((i - 1) * (graphW - 2)) / (hr_history_count - 1);
                int x2 = graphX + 1 + (i * (graphW - 2)) / (hr_history_count - 1);
                int y1 = graphY + graphH - 2 - map(constrain(hr_history[idx1], graphMin, graphMax), graphMin, graphMax, 0, graphH - 4);
                int y2 = graphY + graphH - 2 - map(constrain(hr_history[idx2], graphMin, graphMax), graphMin, graphMax, 0, graphH - 4);
                
                uint16_t lineColor = (hr_history[idx2] > 100) ? RED : (hr_history[idx2] > 60) ? GREEN : YELLOW;
                tftSprite.drawLine(x1, y1, x2, y2, lineColor);
            }
        }
        
        // Graph scale labels
        tftSprite.setTextColor(0x7BEF);
        tftSprite.setCursor(graphX + graphW + 2, graphY);
        tftSprite.printf("%d", graphMax);
        tftSprite.setCursor(graphX + graphW + 2, graphY + graphH - 8);
        tftSprite.printf("%d", graphMin);
    }
    
    // Time label
    tftSprite.setTextColor(0x7BEF);
    tftSprite.setCursor(graphX, graphY + graphH + 2);
    tftSprite.print("-12h");
    tftSprite.setCursor(graphX + graphW - 20, graphY + graphH + 2);
    tftSprite.print("now");
    
    // Controls hint
    tftSprite.setTextColor(0x7BEF);
    tftSprite.drawString("[HOLD] Menu", 35, 180);
    
    // Restore Wire1 to internal for AXP192/RTC
    if (heartRateBus == &Wire1) switchWire1ToInternal();
    
    tftSprite.pushSprite(0, 0);
}

void saveIRCommands() {
    prefs.begin("ir_cmds", false);
    prefs.putUChar("count", irCommandCount);
    for (int i = 0; i < IR_MAX_COMMANDS; i++) {
        String key = "cmd" + String(i);
        prefs.putBytes(key.c_str(), &irCommands[i], sizeof(IRCommand));
    }
    prefs.end();
}

void loadIRCommands() {
    prefs.begin("ir_cmds", true);
    irCommandCount = prefs.getUChar("count", 0);
    for (int i = 0; i < IR_MAX_COMMANDS; i++) {
        String key = "cmd" + String(i);
        prefs.getBytes(key.c_str(), &irCommands[i], sizeof(IRCommand));
    }
    prefs.end();
    
    // Recount valid commands
    irCommandCount = 0;
    for (int i = 0; i < IR_MAX_COMMANDS; i++) {
        if (irCommands[i].used) irCommandCount++;
    }
}

void sendIRCommand(int idx) {
    if (idx < 0 || idx >= IR_MAX_COMMANDS || !irCommands[idx].used) return;
    
    IRCommand& cmd = irCommands[idx];
    
    // Send based on protocol using IRremote library
    switch (cmd.protocol) {
        case NEC:
            IrSender.sendNEC(0, cmd.code, 0);
            break;
        case SONY:
            IrSender.sendSony(0, cmd.code, 0);
            break;
        case RC5:
            IrSender.sendRC5(0, cmd.code);
            break;
        case RC6:
            IrSender.sendRC6(0, cmd.code, 0);
            break;
        case SAMSUNG:
            IrSender.sendSamsung(0, cmd.code, 0);
            break;
        case LG:
            IrSender.sendLG(0, cmd.code, 0);
            break;
        case PANASONIC:
            IrSender.sendPanasonic(0, cmd.code, 0);
            break;
        default:
            // Default to NEC for unknown protocols
            IrSender.sendNEC(0, cmd.code, 0);
            break;
    }
    
    // Ensure IR LED is turned off after sending
    delay(20);
    digitalWrite(IR_SEND_PIN, LOW);
}

// ============== Web Files App Functions ==============

// Initialize LittleFS
bool webFilesInit() {
    if (!LittleFS.begin(true)) {
        Serial.println("LittleFS mount failed");
        return false;
    }
    Serial.println("LittleFS mounted");
    return true;
}

// Scan LittleFS root and populate file list
void webFilesScanDirectory() {
    webFilesCount = 0;
    
    File root = LittleFS.open("/");
    if (!root || !root.isDirectory()) {
        Serial.println("Failed to open root directory");
        return;
    }
    
    File file = root.openNextFile();
    while (file && webFilesCount < WEB_FILES_MAX_FILES) {
        if (!file.isDirectory()) {
            const char* name = file.name();
            // Skip empty filenames
            if (name != NULL && strlen(name) > 0) {
                // Remove leading slash if present for consistent storage
                const char* cleanName = (name[0] == '/') ? name + 1 : name;
                if (strlen(cleanName) > 0) {
                    strncpy(webFilesList[webFilesCount], cleanName, WEB_FILE_NAME_LEN - 1);
                    webFilesList[webFilesCount][WEB_FILE_NAME_LEN - 1] = '\0';
                    Serial.printf("File[%d]: '%s' size=%d\n", webFilesCount, webFilesList[webFilesCount], file.size());
                    webFilesCount++;
                }
            }
        }
        file = root.openNextFile();
    }
    root.close();
    Serial.printf("Found %d files in LittleFS\n", webFilesCount);
}

// Scan for .ir files only
void irFilesScanDirectory() {
    irFilesCount = 0;
    
    File root = LittleFS.open("/");
    if (!root || !root.isDirectory()) return;
    
    File file = root.openNextFile();
    while (file && irFilesCount < WEB_FILES_MAX_FILES) {
        if (!file.isDirectory()) {
            const char* name = file.name();
            if (strstr(name, ".ir") != NULL) {
                strncpy(irFilesList[irFilesCount], name, WEB_FILE_NAME_LEN - 1);
                irFilesList[irFilesCount][WEB_FILE_NAME_LEN - 1] = '\0';
                irFilesCount++;
            }
        }
        file = root.openNextFile();
    }
    root.close();
}

// Delete a file from LittleFS
bool webFilesDeleteFile(const char* filename) {
    if (filename == NULL || strlen(filename) == 0) {
        Serial.println("Delete failed: empty filename");
        return false;
    }
    
    char filepath[64];
    // Handle both cases: filename with or without leading slash
    if (filename[0] == '/') {
        strncpy(filepath, filename, sizeof(filepath) - 1);
    } else {
        snprintf(filepath, sizeof(filepath), "/%s", filename);
    }
    filepath[sizeof(filepath) - 1] = '\0';
    
    Serial.printf("Attempting to delete: '%s'\n", filepath);
    
    // Check if file exists first
    if (!LittleFS.exists(filepath)) {
        Serial.printf("File does not exist: %s\n", filepath);
        // Try without leading slash as fallback
        if (filepath[0] == '/' && LittleFS.exists(filepath + 1)) {
            if (LittleFS.remove(filepath + 1)) {
                Serial.printf("Deleted (no slash): %s\n", filepath + 1);
                return true;
            }
        }
        return false;
    }
    
    if (LittleFS.remove(filepath)) {
        Serial.printf("Deleted: %s\n", filepath);
        return true;
    }
    Serial.printf("Failed to delete: %s\n", filepath);
    return false;
}

// Web server HTML page
const char WEB_FILES_HTML[] PROGMEM = R"rawliteral(
<!DOCTYPE html>
<html>
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>M5StickC Tricorder - File Manager</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; background: #1a1a2e; color: #eee; }
        h1 { color: #00d4ff; }
        .container { max-width: 600px; margin: 0 auto; }
        .upload-form { background: #16213e; padding: 20px; border-radius: 10px; margin: 20px 0; }
        input[type="file"] { margin: 10px 0; color: #eee; }
        input[type="submit"] { background: #00d4ff; color: #000; padding: 10px 20px; border: none; border-radius: 5px; cursor: pointer; font-weight: bold; }
        input[type="submit"]:hover { background: #00a8cc; }
        .file-list { background: #16213e; padding: 20px; border-radius: 10px; }
        .file-item { padding: 10px; border-bottom: 1px solid #333; display: flex; justify-content: space-between; align-items: center; }
        .file-item:last-child { border-bottom: none; }
        .file-info { font-size: 12px; color: #888; }
        .delete-btn { background: #e94560; color: #fff; padding: 5px 10px; border: none; border-radius: 3px; cursor: pointer; }
        .delete-btn:hover { background: #c73e54; }
        .info { margin-top: 20px; font-size: 12px; color: #888; }
        a { color: #00d4ff; }
    </style>
</head>
<body>
    <div class="container">
        <h1>&#128193; File Manager</h1>
        <div class="upload-form">
            <h3>Upload File</h3>
            <form method="POST" action="/upload" enctype="multipart/form-data">
                <input type="file" name="file"><br>
                <input type="submit" value="Upload">
            </form>
        </div>
        <div class="file-list">
            <h3>Files on Device</h3>
            <div id="files">%FILES%</div>
        </div>
        <div class="info">
            <p>Upload .ir files from <a href="https://github.com/Lucaslhm/Flipper-IRDB">Flipper-IRDB</a> to use with IR Remote app</p>
            <p>Free space: %FREESPACE% bytes</p>
        </div>
        <div class="upload-form" style="margin-top:20px; background:#3d1a1a;">
            <h3 style="color:#e94560;">Danger Zone</h3>
            <p style="font-size:12px; color:#888;">This will delete ALL files and reset the filesystem.</p>
            <form method="POST" action="/format" onsubmit="return confirm('Are you sure you want to FORMAT and delete ALL files?');">
                <input type="submit" value="Format LittleFS" style="background:#e94560;">
            </form>
        </div>
    </div>
</body>
</html>
)rawliteral";

// Generate file list HTML
String webFilesGetFileListHTML() {
    String html = "";
    webFilesScanDirectory();
    
    if (webFilesCount == 0) {
        html = "<p style='color:#888'>No files uploaded yet</p>";
    } else {
        for (int i = 0; i < webFilesCount; i++) {
            File f = LittleFS.open(String("/") + webFilesList[i], "r");
            size_t fsize = f ? f.size() : 0;
            if (f) f.close();
            
            html += "<div class='file-item'><div><span>" + String(webFilesList[i]) + "</span>";
            html += "<div class='file-info'>" + String(fsize) + " bytes</div></div>";
            html += "<form method='POST' action='/delete' style='margin:0'>";
            html += "<input type='hidden' name='file' value='" + String(webFilesList[i]) + "'>";
            html += "<input type='submit' class='delete-btn' value='Delete'>";
            html += "</form></div>";
        }
    }
    return html;
}

// Web server handlers
void webFilesHandleRoot() {
    String html = String(WEB_FILES_HTML);
    html.replace("%FILES%", webFilesGetFileListHTML());
    html.replace("%FREESPACE%", String(LittleFS.totalBytes() - LittleFS.usedBytes()));
    webFilesServer.send(200, "text/html", html);
}

void webFilesHandleUpload() {
    HTTPUpload& upload = webFilesServer.upload();
    static File uploadFile;
    
    if (upload.status == UPLOAD_FILE_START) {
        String filename = "/" + upload.filename;
        Serial.printf("Upload Start: %s\n", filename.c_str());
        uploadFile = LittleFS.open(filename, "w");
    }
    else if (upload.status == UPLOAD_FILE_WRITE) {
        if (uploadFile) {
            uploadFile.write(upload.buf, upload.currentSize);
        }
    }
    else if (upload.status == UPLOAD_FILE_END) {
        if (uploadFile) {
            uploadFile.close();
            Serial.printf("Upload End: %s (%d bytes)\n", upload.filename.c_str(), upload.totalSize);
        }
    }
}

void webFilesHandleUploadComplete() {
    webFilesServer.sendHeader("Location", "/");
    webFilesServer.send(303);
}

void webFilesHandleDelete() {
    if (webFilesServer.hasArg("file")) {
        String filename = webFilesServer.arg("file");
        webFilesDeleteFile(filename.c_str());
    }
    webFilesServer.sendHeader("Location", "/");
    webFilesServer.send(303);
}

void webFilesHandleFormat() {
    Serial.println("Formatting LittleFS...");
    LittleFS.end();
    if (LittleFS.format()) {
        Serial.println("LittleFS formatted successfully");
        LittleFS.begin(true);
        webFilesServer.send(200, "text/html", "<html><body style='background:#1a1a2e;color:#eee;font-family:Arial;text-align:center;padding-top:50px;'><h1 style='color:#00d4ff;'>LittleFS Formatted</h1><p>All files have been deleted.</p><a href='/' style='color:#00d4ff;'>Back to File Manager</a></body></html>");
    } else {
        Serial.println("LittleFS format failed");
        LittleFS.begin(true);
        webFilesServer.send(500, "text/html", "<html><body style='background:#1a1a2e;color:#eee;font-family:Arial;text-align:center;padding-top:50px;'><h1 style='color:red;'>Format Failed</h1><a href='/' style='color:#00d4ff;'>Back to File Manager</a></body></html>");
    }
}

// Start WiFi AP and web server
void webFilesStartWiFi() {
    Serial.println("Starting WiFi AP...");
    Serial.printf("Free heap: %d\n", ESP.getFreeHeap());
    
    delay(200);
    
    // Configure AP IP address first
    IPAddress local_IP(192, 168, 4, 1);
    IPAddress gateway(192, 168, 4, 1);
    IPAddress subnet(255, 255, 255, 0);
    
    if (!WiFi.softAPConfig(local_IP, gateway, subnet)) {
        Serial.println("softAPConfig failed!");
    }
    
    // Start the AP with SSID and WPA password
    Serial.printf("Calling softAP with SSID: %s, Password: %s\n", WEB_FILES_SSID, WEB_FILES_PASSWORD);
    bool apStarted = WiFi.softAP(WEB_FILES_SSID, WEB_FILES_PASSWORD, 1, 0, 4);  // channel 1, not hidden, max 4 connections
    
    Serial.printf("softAP returned: %d\n", apStarted);
    delay(1000);  // Give AP more time to start
    
    IPAddress IP = WiFi.softAPIP();
    Serial.printf("IP address: %s\n", IP.toString().c_str());
    
    if (IP[0] != 0) {  // Check if IP is valid (not 0.0.0.0)
        Serial.println("WiFi AP started successfully!");
        
        webFilesServer.on("/", HTTP_GET, webFilesHandleRoot);
        webFilesServer.on("/upload", HTTP_POST, webFilesHandleUploadComplete, webFilesHandleUpload);
        webFilesServer.on("/delete", HTTP_POST, webFilesHandleDelete);
        webFilesServer.on("/format", HTTP_POST, webFilesHandleFormat);
        webFilesServer.begin();
        Serial.println("Web server started");
        
        webFilesWiFiEnabled = true;
    } else {
        Serial.println("WiFi AP failed - IP is 0.0.0.0!");
        webFilesWiFiEnabled = false;
    }
}

// Stop WiFi AP and web server
void webFilesStopWiFi() {
    webFilesServer.stop();
    WiFi.softAPdisconnect(true);
    WiFi.mode(WIFI_OFF);
    webFilesWiFiEnabled = false;
    Serial.println("WiFi AP stopped");
}

// ============== Flipper IR File Parser ==============

// Parse protocol string from Flipper format
uint8_t parseFlipperProtocol(const char* proto) {
    if (strcasecmp(proto, "NEC") == 0 || strcasecmp(proto, "NECext") == 0) return 0;
    if (strcasecmp(proto, "Samsung") == 0 || strcasecmp(proto, "Samsung32") == 0) return 1;
    if (strcasecmp(proto, "Sony") == 0 || strncasecmp(proto, "SIRC", 4) == 0) return 2;
    if (strcasecmp(proto, "RC5") == 0 || strcasecmp(proto, "RC5X") == 0) return 3;
    if (strcasecmp(proto, "RC6") == 0) return 4;
    if (strcasecmp(proto, "LG") == 0 || strcasecmp(proto, "LG32") == 0) return 5;
    if (strcasecmp(proto, "Panasonic") == 0 || strcasecmp(proto, "Kaseikyo") == 0) return 6;
    return 0;  // Default to NEC
}

// Parse hex bytes from Flipper format (e.g., "45 00 00 00" -> 0x45)
uint32_t parseFlipperHex(const char* hexStr) {
    uint32_t result = 0;
    char* ptr = (char*)hexStr;
    int byteCount = 0;
    
    while (*ptr && byteCount < 4) {
        while (*ptr == ' ') ptr++;
        if (*ptr == '\0') break;
        
        uint8_t byte = (uint8_t)strtol(ptr, &ptr, 16);
        result |= ((uint32_t)byte << (byteCount * 8));
        byteCount++;
    }
    return result;
}

// Load and parse a Flipper IR file
bool irFileLoad(const char* filename) {
    char filepath[64];
    snprintf(filepath, sizeof(filepath), "/%s", filename);
    
    File file = LittleFS.open(filepath, "r");
    if (!file) {
        Serial.printf("Failed to open %s\n", filepath);
        return false;
    }
    
    // Clear current commands
    irFileCommandCount = 0;
    memset(irFileCommands, 0, sizeof(irFileCommands));
    strncpy(irCurrentFileName, filename, WEB_FILE_NAME_LEN - 1);
    
    char line[128];
    FlipperIRCmd currentCmd;
    memset(&currentCmd, 0, sizeof(currentCmd));
    bool inCommand = false;
    
    while (file.available() && irFileCommandCount < IR_FILE_MAX_CMDS) {
        size_t len = file.readBytesUntil('\n', line, sizeof(line) - 1);
        line[len] = '\0';
        
        // Trim trailing whitespace
        while (len > 0 && (line[len-1] == '\r' || line[len-1] == '\n' || line[len-1] == ' ')) {
            line[--len] = '\0';
        }
        
        // Skip empty lines and comments
        if (len == 0 || line[0] == '#') continue;
        
        // Parse key: value pairs
        char* colon = strchr(line, ':');
        if (!colon) continue;
        
        *colon = '\0';
        char* key = line;
        char* value = colon + 1;
        while (*value == ' ') value++;
        
        if (strcasecmp(key, "name") == 0) {
            // Save previous command if valid
            if (inCommand && currentCmd.valid) {
                irFileCommands[irFileCommandCount++] = currentCmd;
            }
            // Start new command
            memset(&currentCmd, 0, sizeof(currentCmd));
            strncpy(currentCmd.name, value, IR_FILE_CMD_NAME_LEN - 1);
            inCommand = true;
        }
        else if (strcasecmp(key, "type") == 0) {
            if (strcasecmp(value, "parsed") == 0) {
                currentCmd.valid = true;
            }
        }
        else if (strcasecmp(key, "protocol") == 0) {
            currentCmd.protocol = parseFlipperProtocol(value);
        }
        else if (strcasecmp(key, "address") == 0) {
            currentCmd.address = parseFlipperHex(value);
        }
        else if (strcasecmp(key, "command") == 0) {
            currentCmd.command = parseFlipperHex(value);
        }
    }
    
    // Save last command
    if (inCommand && currentCmd.valid) {
        irFileCommands[irFileCommandCount++] = currentCmd;
    }
    
    file.close();
    Serial.printf("Loaded %d commands from %s\n", irFileCommandCount, filename);
    return irFileCommandCount > 0;
}

// Send a Flipper IR command
void irFileSendCommand(int idx) {
    if (idx < 0 || idx >= irFileCommandCount) return;
    
    FlipperIRCmd& cmd = irFileCommands[idx];
    if (!cmd.valid) return;
    
    Serial.printf("Sending IR: %s (proto=%d, addr=0x%04X, cmd=0x%04X)\n", 
                  cmd.name, cmd.protocol, cmd.address, cmd.command);
    
    switch (cmd.protocol) {
        case 0:  // NEC
            IrSender.sendNEC(cmd.address & 0xFFFF, cmd.command & 0xFF, 0);
            break;
        case 1:  // Samsung
            IrSender.sendSamsung(cmd.address & 0xFFFF, cmd.command & 0xFF, 0);
            break;
        case 2:  // Sony
            IrSender.sendSony(cmd.address & 0x1F, cmd.command & 0x7F, 0);
            break;
        case 3:  // RC5
            IrSender.sendRC5(cmd.address & 0x1F, cmd.command & 0x3F);
            break;
        case 4:  // RC6
            IrSender.sendRC6(cmd.address & 0xFF, cmd.command & 0xFF, 0);
            break;
        case 5:  // LG
            IrSender.sendLG(cmd.address & 0xFF, cmd.command & 0xFFFF, 0);
            break;
        case 6:  // Panasonic
            IrSender.sendPanasonic(cmd.address & 0xFFFF, cmd.command & 0xFFFFFF, 0);
            break;
        default:
            IrSender.sendNEC(cmd.address & 0xFFFF, cmd.command & 0xFF, 0);
            break;
    }
    
    // Ensure IR LED is turned off after sending
    delay(20);
    digitalWrite(IR_SEND_PIN, LOW);
}

// ============== Web Files App UI ==============

void app_web_files() {
    tftSprite.fillRect(0, 0, 135, 240, BLACK);
    drawHeader();
    
    // Title
    tftSprite.setTextColor(CYAN);
    tftSprite.drawString("WEB FILES", 40, 20);
    
    if (webFilesAppState == WEBFILES_WIFI_ON) {
        // WiFi is enabled - show connection info
        tftSprite.setTextColor(GREEN);
        tftSprite.drawString("WiFi AP Active", 25, 42);
        
        tftSprite.setTextColor(WHITE);
        tftSprite.drawString("SSID:", 10, 62);
        tftSprite.setTextColor(YELLOW);
        tftSprite.drawString(WEB_FILES_SSID, 45, 62);
        
        tftSprite.setTextColor(WHITE);
        tftSprite.drawString("Pass:", 10, 77);
        tftSprite.setTextColor(YELLOW);
        tftSprite.drawString(WEB_FILES_PASSWORD, 45, 77);
        
        tftSprite.setTextColor(WHITE);
        tftSprite.drawString("IP:", 10, 92);
        tftSprite.setTextColor(YELLOW);
        IPAddress ip = WiFi.softAPIP();
        tftSprite.drawString(ip.toString().c_str(), 30, 92);
        
        // Connected clients
        tftSprite.setTextColor(WHITE);
        tftSprite.drawString("Clients:", 10, 110);
        tftSprite.setTextColor(CYAN);
        tftSprite.printf("%d", WiFi.softAPgetStationNum());
        
        // File count
        webFilesScanDirectory();
        tftSprite.setTextColor(WHITE);
        tftSprite.setCursor(10, 128);
        tftSprite.printf("Files: %d", webFilesCount);
        
        // Instructions
        tftSprite.setTextColor(0x7BEF);
        tftSprite.drawString("Connect to WiFi and", 10, 155);
        tftSprite.drawString("open browser to IP", 10, 170);
        
        tftSprite.setTextColor(RED);
        tftSprite.drawString("[A] Stop WiFi", 25, 210);
        
    } else if (webFilesAppState == WEBFILES_LIST) {
        // Show file list
        webFilesScanDirectory();
        
        tftSprite.drawLine(10, 35, 125, 35, 0x7BEF);
        
        const int itemHeight = 16;
        const int listStartY = 40;
        const int visibleItems = 9;
        
        int scrollOffset = 0;
        if (webFilesSelectedFile >= visibleItems) {
            scrollOffset = webFilesSelectedFile - visibleItems + 1;
        }
        
        if (webFilesCount == 0) {
            tftSprite.setTextColor(0x7BEF);
            tftSprite.drawString("No files", 45, 80);
        } else {
            for (int i = 0; i < visibleItems && (i + scrollOffset) < webFilesCount; i++) {
                int idx = i + scrollOffset;
                int y = listStartY + i * itemHeight;
                
                bool isSelected = (idx == webFilesSelectedFile);
                
                if (isSelected) {
                    tftSprite.fillRect(5, y - 1, 125, itemHeight - 2, 0x2104);
                }
                
                tftSprite.setTextColor(isSelected ? WHITE : GREEN);
                tftSprite.setCursor(10, y);
                
                // Truncate long filenames
                char displayName[20];
                strncpy(displayName, webFilesList[idx], 19);
                displayName[19] = '\0';
                tftSprite.print(displayName);
            }
        }
        
        // Controls
        tftSprite.setTextColor(0x7BEF);
        tftSprite.drawString("[A] Delete [B] Next", 10, 200);
        tftSprite.drawString("[HOLD] Menu", 35, 215);
        
    } else {
        // Main menu
        tftSprite.setTextColor(WHITE);
        tftSprite.drawString("Manage files via WiFi", 10, 50);
        
        // File count
        webFilesScanDirectory();
        tftSprite.setTextColor(CYAN);
        tftSprite.setCursor(10, 75);
        tftSprite.printf("Files stored: %d", webFilesCount);
        
        // Free space
        size_t freeSpace = LittleFS.totalBytes() - LittleFS.usedBytes();
        tftSprite.setCursor(10, 90);
        tftSprite.printf("Free: %d bytes", freeSpace);
        
        // Menu options
        tftSprite.setTextColor(GREEN);
        tftSprite.drawString("[A] Start WiFi AP", 15, 130);
        tftSprite.setTextColor(YELLOW);
        tftSprite.drawString("[B] View Files", 15, 150);
        
        tftSprite.setTextColor(0x7BEF);
        tftSprite.drawString("[HOLD] Menu", 35, 200);
    }
    
    tftSprite.pushSprite(0, 0);
}

void app_ir_remote() {
    tftSprite.fillRect(0, 0, 135, 240, BLACK);
    drawHeader();
    
    // Title
    tftSprite.setTextColor(CYAN);
    tftSprite.drawString("IR REMOTE", 40, 20);
    
    static bool irRecvStarted = false;
    static int32_t irEncoderBase = 0;
    static unsigned long lastSendTime = 0;
    
    // Initialize IR receiver on first entry
    if (!irRecvStarted) {
        IrReceiver.begin(IR_RECEIVE_PIN, ENABLE_LED_FEEDBACK);
        irRecvStarted = true;
        if (encoderConnected) {
            irEncoderBase = sensor.getEncoderValue();
        }
    }
    
    // Handle encoder for all states
    int32_t encVal = encoderConnected ? sensor.getEncoderValue() : 0;
    int32_t encDelta = encVal - irEncoderBase;
    
    if (irFileState == IRFILE_SELECT_FILE) {
        // File selection mode - show .ir files from LittleFS
        tftSprite.setTextColor(YELLOW);
        tftSprite.drawString("Select IR File", 25, 38);
        tftSprite.drawLine(10, 50, 125, 50, 0x7BEF);
        
        // Handle encoder navigation
        if (abs(encDelta) >= 2) {
            int steps = encDelta / 2;
            irFileSelectedFile += steps;
            if (irFileSelectedFile < 0) irFileSelectedFile = irFilesCount - 1;
            if (irFileSelectedFile >= irFilesCount) irFileSelectedFile = 0;
            irEncoderBase = encVal;
        }
        
        const int itemHeight = 16;
        const int listStartY = 55;
        const int visibleItems = 8;
        
        int scrollOffset = 0;
        if (irFileSelectedFile >= visibleItems) {
            scrollOffset = irFileSelectedFile - visibleItems + 1;
        }
        
        if (irFilesCount == 0) {
            tftSprite.setTextColor(0x7BEF);
            tftSprite.drawString("No .ir files found", 15, 90);
            tftSprite.drawString("Upload via Web Files", 10, 110);
        } else {
            for (int i = 0; i < visibleItems && (i + scrollOffset) < irFilesCount; i++) {
                int idx = i + scrollOffset;
                int y = listStartY + i * itemHeight;
                
                bool isSelected = (idx == irFileSelectedFile);
                
                if (isSelected) {
                    tftSprite.fillRect(5, y - 1, 125, itemHeight - 2, 0x2104);
                }
                
                tftSprite.setTextColor(isSelected ? WHITE : GREEN);
                tftSprite.setCursor(10, y);
                
                // Truncate long filenames
                char displayName[18];
                strncpy(displayName, irFilesList[idx], 17);
                displayName[17] = '\0';
                tftSprite.print(displayName);
            }
        }
        
        // Controls
        tftSprite.setTextColor(0x7BEF);
        tftSprite.drawString("[A] Load [B] Next", 15, 195);
        tftSprite.drawString("[HOLD] Back/Menu", 25, 210);
        
    } else if (irFileState == IRFILE_SELECT_CMD) {
        // Command selection from loaded file
        tftSprite.setTextColor(YELLOW);
        // Show truncated filename
        char shortName[14];
        strncpy(shortName, irCurrentFileName, 13);
        shortName[13] = '\0';
        tftSprite.drawString(shortName, 5, 38);
        tftSprite.drawLine(10, 50, 125, 50, 0x7BEF);
        
        // Handle encoder navigation
        if (abs(encDelta) >= 2) {
            int steps = encDelta / 2;
            irFileSelectedCmd += steps;
            if (irFileSelectedCmd < 0) irFileSelectedCmd = irFileCommandCount - 1;
            if (irFileSelectedCmd >= irFileCommandCount) irFileSelectedCmd = 0;
            irEncoderBase = encVal;
        }
        
        const int itemHeight = 16;
        const int listStartY = 55;
        const int visibleItems = 8;
        
        int scrollOffset = 0;
        if (irFileSelectedCmd >= visibleItems) {
            scrollOffset = irFileSelectedCmd - visibleItems + 1;
        }
        
        for (int i = 0; i < visibleItems && (i + scrollOffset) < irFileCommandCount; i++) {
            int idx = i + scrollOffset;
            int y = listStartY + i * itemHeight;
            
            bool isSelected = (idx == irFileSelectedCmd);
            
            if (isSelected) {
                tftSprite.fillRect(5, y - 1, 125, itemHeight - 2, 0x2104);
            }
            
            tftSprite.setTextColor(isSelected ? WHITE : GREEN);
            tftSprite.setCursor(10, y);
            
            // Truncate command name
            char displayName[18];
            strncpy(displayName, irFileCommands[idx].name, 17);
            displayName[17] = '\0';
            tftSprite.print(displayName);
        }
        
        // Controls
        tftSprite.setTextColor(0x7BEF);
        tftSprite.drawString("[A] Send [B] Next", 15, 195);
        tftSprite.drawString("[HOLD] Back/Menu", 25, 210);
        
    } else if (irAppState == IR_LIST) {
        // Main list - learned commands + Load File option
        
        // Handle encoder navigation
        if (abs(encDelta) >= 2) {
            int steps = encDelta / 2;
            irSelectedCmd += steps;
            // Items: learned commands + "Load File"
            int maxIdx = irCommandCount;  // Last item is "Load File"
            if (irSelectedCmd < 0) irSelectedCmd = maxIdx;
            if (irSelectedCmd > maxIdx) irSelectedCmd = 0;
            irEncoderBase = encVal;
        }
        
        tftSprite.drawLine(10, 35, 125, 35, 0x7BEF);
        
        const int itemHeight = 18;
        const int listStartY = 40;
        const int visibleItems = 7;
        
        int scrollOffset = 0;
        int totalItems = irCommandCount + 1;  // +1 for "Load File"
        if (irSelectedCmd > visibleItems - 1) {
            scrollOffset = irSelectedCmd - visibleItems + 1;
        }
        
        for (int i = 0; i < visibleItems && (i + scrollOffset) < totalItems; i++) {
            int idx = i + scrollOffset;
            int y = listStartY + i * itemHeight;
            
            bool isSelected = (idx == irSelectedCmd);
            
            if (isSelected) {
                tftSprite.fillRect(5, y - 1, 125, itemHeight - 2, 0x2104);
            }
            
            tftSprite.setCursor(10, y);
            
            if (idx < irCommandCount) {
                // Find the idx-th used command
                int cmdIdx = -1;
                int count = 0;
                for (int j = 0; j < IR_MAX_COMMANDS; j++) {
                    if (irCommands[j].used) {
                        if (count == idx) {
                            cmdIdx = j;
                            break;
                        }
                        count++;
                    }
                }
                
                if (cmdIdx >= 0) {
                    tftSprite.setTextColor(isSelected ? WHITE : GREEN);
                    tftSprite.print(irCommands[cmdIdx].name);
                    
                    // Show protocol (first 4 chars)
                    tftSprite.setTextColor(0x7BEF);
                    tftSprite.setCursor(85, y);
                    const char* protoStr = getProtocolString((decode_type_t)irCommands[cmdIdx].protocol);
                    char protoShort[5] = {0};
                    strncpy(protoShort, protoStr, 4);
                    tftSprite.print(protoShort);
                }
            } else {
                // "Load File" option
                tftSprite.setTextColor(isSelected ? WHITE : CYAN);
                tftSprite.print("@ Load .ir File");
            }
        }
        
        // Scroll indicator
        if (totalItems > visibleItems) {
            int scrollBarH = (visibleItems * (visibleItems * itemHeight)) / totalItems;
            int scrollBarY = listStartY + (scrollOffset * (visibleItems * itemHeight - scrollBarH)) / (totalItems - visibleItems);
            tftSprite.fillRect(132, scrollBarY, 2, scrollBarH, 0x7BEF);
        }
        
        // Controls hint
        tftSprite.setTextColor(0x7BEF);
        tftSprite.setCursor(5, 175);
        if (irSelectedCmd < irCommandCount) {
            tftSprite.print("[A] Send [B] Next");
        } else {
            tftSprite.print("[A] Browse [B] Next");
        }
        tftSprite.setCursor(25, 190);
        tftSprite.print("[HOLD] Menu");
    }
    
    tftSprite.pushSprite(0, 0);
}

void app_level() {
    tftSprite.fillRect(0, 0, 135, 240, BLACK);
    drawHeader();
    
    // Title
    tftSprite.setTextColor(CYAN);
    tftSprite.drawString("3D LEVEL", 45, 20);
    
    // Read IMU data
    float accX, accY, accZ;
    float gyroX, gyroY, gyroZ;
    
    // Re-init IMU if needed (BLE may have interfered)
    static bool imuReinitialized = false;
    if (!imuReinitialized) {
        M5.Imu.Init();
        imuReinitialized = true;
        Serial.println("IMU re-initialized in app_level");
    }
    
    M5.Imu.getAccelData(&accX, &accY, &accZ);
    M5.Imu.getGyroData(&gyroX, &gyroY, &gyroZ);
    
    
    // Calculate pitch and roll from accelerometer (stable, no drift)
    levelPitch = atan2(accX, sqrt(accY * accY + accZ * accZ)) * 180.0 / PI;
    levelRoll = atan2(accY, sqrt(accX * accX + accZ * accZ)) * 180.0 / PI;
    
    // Draw graphical level indicator (bubble level style)
    int centerX = 67;
    int centerY = 95;
    int radius = 40;
    
    // Draw outer circle
    tftSprite.drawCircle(centerX, centerY, radius, WHITE);
    tftSprite.drawCircle(centerX, centerY, radius + 1, WHITE);
    
    // Draw crosshairs
    tftSprite.drawLine(centerX - radius - 5, centerY, centerX + radius + 5, centerY, 0x4208);
    tftSprite.drawLine(centerX, centerY - radius - 5, centerX, centerY + radius + 5, 0x4208);
    
    // Draw center target circles
    tftSprite.drawCircle(centerX, centerY, 5, 0x7BEF);
    tftSprite.drawCircle(centerX, centerY, 15, 0x4208);
    tftSprite.drawCircle(centerX, centerY, 25, 0x4208);
    
    // Calculate bubble position based on pitch and roll
    // Clamp to circle bounds
    float bubbleX = constrain(levelRoll * 2, -radius + 5, radius - 5);
    float bubbleY = constrain(-levelPitch * 2, -radius + 5, radius - 5);
    
    // Draw bubble (filled circle)
    uint16_t bubbleColor = GREEN;
    if (abs(levelPitch) < 2 && abs(levelRoll) < 2) {
        bubbleColor = GREEN;  // Level
    } else if (abs(levelPitch) < 5 && abs(levelRoll) < 5) {
        bubbleColor = YELLOW;  // Close
    } else {
        bubbleColor = RED;  // Off level
    }
    tftSprite.fillCircle(centerX + (int)bubbleX, centerY + (int)bubbleY, 8, bubbleColor);
    tftSprite.drawCircle(centerX + (int)bubbleX, centerY + (int)bubbleY, 8, WHITE);
    
    // Display angle values
    tftSprite.setTextSize(1);
    tftSprite.setTextColor(WHITE);
    
    // Pitch (X rotation)
    tftSprite.setCursor(5, 145);
    tftSprite.print("Pitch:");
    tftSprite.setTextColor(levelPitch > 0 ? CYAN : MAGENTA);
    tftSprite.printf("%+6.1f", levelPitch);
    tftSprite.setTextColor(WHITE);
    tftSprite.print((char)247);  // Degree symbol
    
    // Roll (Y rotation)
    tftSprite.setCursor(5, 158);
    tftSprite.setTextColor(WHITE);
    tftSprite.print("Roll: ");
    tftSprite.setTextColor(levelRoll > 0 ? CYAN : MAGENTA);
    tftSprite.printf("%+6.1f", levelRoll);
    tftSprite.setTextColor(WHITE);
    tftSprite.print((char)247);
    
    // Alarm status - show below angle values
    if (levelAlarmArmed) {
        // Check for angle change (only pitch and roll - yaw drifts without magnetometer)
        float pitchDiff = abs(levelPitch - levelRefPitch);
        float rollDiff = abs(levelRoll - levelRefRoll);
        
        if (pitchDiff > levelAlarmThreshold || rollDiff > levelAlarmThreshold) {
            levelAlarmTriggered = true;
        }
        
        // Draw alarm indicator on separate line
        tftSprite.setCursor(5, 184);
        if (levelAlarmTriggered) {
            tftSprite.setTextColor(RED);
            tftSprite.print("!! ALARM !!");
        } else {
            tftSprite.setTextColor(GREEN);
            tftSprite.printf("ARMED Th:%+.0f", levelAlarmThreshold);
            tftSprite.print((char)247);
        }
        
        // Controls hint
        tftSprite.setTextColor(0x7BEF);
        tftSprite.setCursor(5, 200);
        tftSprite.print("[A] Disarm [B] Stop");
    } else {
        // Controls hint when not armed
        tftSprite.setTextColor(0x7BEF);
        tftSprite.setCursor(5, 184);
        tftSprite.printf("Threshold: %.0f", levelAlarmThreshold);
        tftSprite.print((char)247);
        tftSprite.setCursor(5, 200);
        tftSprite.print("[A] Arm alarm");
    }
    
    // Encoder hint
    tftSprite.setTextColor(0x4208);
    tftSprite.setCursor(5, 216);
    tftSprite.print("Encoder: adj threshold");
    
    tftSprite.pushSprite(0, 0);
}

void app_distance() {
    tftSprite.fillRect(0, 0, 135, 240, BLACK);
    drawHeader();
    
    // Title
    tftSprite.setTextColor(CYAN);
    tftSprite.drawString("DISTANCE", 40, 20);
    
    // Read TOF sensor
    if (tofInitialized) {
        // Switch to Grove if sensor is on Grove port
        if (tofBus == &Wire1) switchWire1ToGrove();
        
        tofDistance = tofSensor.readRangeContinuousMillimeters();
        
        // Restore Wire1 to internal for AXP192/RTC
        if (tofBus == &Wire1) switchWire1ToInternal();
        
        // Check for timeout/error
        if (tofSensor.timeoutOccurred()) {
            tftSprite.setTextColor(RED);
            tftSprite.setCursor(20, 80);
            tftSprite.print("TIMEOUT");
        } else {
            // Display distance in large font
            tftSprite.setTextSize(1);
            tftSprite.setTextColor(WHITE);
            tftSprite.setCursor(30, 50);
            tftSprite.print("Distance:");
            
            // Large distance value
            tftSprite.setTextSize(3);
            
            // Color based on distance
            if (tofDistance < 100) {
                tftSprite.setTextColor(RED);
            } else if (tofDistance < 300) {
                tftSprite.setTextColor(YELLOW);
            } else if (tofDistance < 1000) {
                tftSprite.setTextColor(GREEN);
            } else {
                tftSprite.setTextColor(CYAN);
            }
            
            // Center the distance value
            char distStr[10];
            if (tofDistance >= 8190) {
                sprintf(distStr, "OOR");  // Out of range
                tftSprite.setTextColor(0x7BEF);
            } else {
                sprintf(distStr, "%d", tofDistance);
            }
            int strWidth = strlen(distStr) * 18;  // Approximate width at size 3
            tftSprite.setCursor((135 - strWidth) / 2, 85);
            tftSprite.print(distStr);
            
            // Unit
            tftSprite.setTextSize(2);
            tftSprite.setTextColor(WHITE);
            tftSprite.setCursor(50, 125);
            tftSprite.print("mm");
            
            // Also show in cm and inches
            tftSprite.setTextSize(1);
            tftSprite.setTextColor(0x7BEF);
            if (tofDistance < 8190) {
                tftSprite.setCursor(20, 160);
                tftSprite.printf("%.1f cm", tofDistance / 10.0);
                tftSprite.setCursor(20, 175);
                tftSprite.printf("%.2f in", tofDistance / 25.4);
            }
            
            // Draw a simple bar graph
            int barY = 200;
            int barHeight = 15;
            int maxDist = 2000;  // Max distance for bar (2m)
            int barWidth = constrain(map(tofDistance, 0, maxDist, 0, 125), 0, 125);
            
            tftSprite.drawRect(5, barY, 125, barHeight, WHITE);
            if (barWidth > 0) {
                uint16_t barColor = tofDistance < 300 ? RED : (tofDistance < 1000 ? YELLOW : GREEN);
                tftSprite.fillRect(5, barY, barWidth, barHeight, barColor);
            }
        }
    } else {
        tftSprite.setTextColor(RED);
        tftSprite.setCursor(10, 80);
        tftSprite.print("TOF not found");
    }
    
    tftSprite.pushSprite(0, 0);
}

void app_tof_counter() {
    tftSprite.fillRect(0, 0, 135, 240, BLACK);
    drawHeader();
    
    // Title
    tftSprite.setTextColor(CYAN);
    tftSprite.drawString("TOF COUNTER", 30, 20);
    
    // Read TOF sensor and update counter logic
    if (tofInitialized) {
        // Switch to Grove if sensor is on Grove port
        if (tofBus == &Wire1) switchWire1ToGrove();
        
        tofDistance = tofSensor.readRangeContinuousMillimeters();
        
        // Restore Wire1 to internal for AXP192/RTC
        if (tofBus == &Wire1) switchWire1ToInternal();
        
        // Track min/max for display
        if (tofDistance < tofMinDistance) tofMinDistance = tofDistance;
        if (tofDistance > tofMaxDistance) tofMaxDistance = tofDistance;
        
        // State machine for counting objects
        // Object detected when distance drops below near threshold
        // Object counted when distance rises above far threshold (hysteresis)
        if (!tofObjectPresent && tofDistance < tofThresholdNear) {
            tofObjectPresent = true;
            // Object just entered detection zone
        } else if (tofObjectPresent && tofDistance > tofThresholdFar) {
            tofObjectPresent = false;
            tofCount++;  // Count when object leaves
            // Reset min/max for next cycle
            tofMinDistance = 8190;
            tofMaxDistance = 0;
        }
        
        // Display count in large font
        tftSprite.setTextSize(1);
        tftSprite.setTextColor(WHITE);
        tftSprite.setCursor(45, 45);
        tftSprite.print("Count:");
        
        // Large count value
        tftSprite.setTextSize(4);
        tftSprite.setTextColor(GREEN);
        char countStr[12];
        sprintf(countStr, "%lu", tofCount);
        int strWidth = strlen(countStr) * 24;
        tftSprite.setCursor((135 - strWidth) / 2, 70);
        tftSprite.print(countStr);
        
        // Current distance
        tftSprite.setTextSize(1);
        tftSprite.setTextColor(WHITE);
        tftSprite.setCursor(10, 120);
        tftSprite.print("Dist: ");
        if (tofDistance >= 8190) {
            tftSprite.setTextColor(0x7BEF);
            tftSprite.print("OOR");
        } else {
            tftSprite.setTextColor(tofObjectPresent ? RED : GREEN);
            tftSprite.printf("%d mm", tofDistance);
        }
        
        // Object status indicator
        tftSprite.setCursor(10, 138);
        tftSprite.setTextColor(WHITE);
        tftSprite.print("Status: ");
        if (tofObjectPresent) {
            tftSprite.setTextColor(RED);
            tftSprite.print("OBJECT");
        } else {
            tftSprite.setTextColor(GREEN);
            tftSprite.print("CLEAR");
        }
        
        // Thresholds
        tftSprite.setTextColor(0x7BEF);
        tftSprite.setCursor(10, 160);
        tftSprite.printf("Near: %d mm", tofThresholdNear);
        tftSprite.setCursor(10, 175);
        tftSprite.printf("Far:  %d mm", tofThresholdFar);
        
        // Visual indicator bar
        int barY = 195;
        int barHeight = 20;
        tftSprite.drawRect(5, barY, 125, barHeight, WHITE);
        
        // Draw threshold markers
        int nearMark = map(tofThresholdNear, 0, 2000, 0, 125);
        int farMark = map(tofThresholdFar, 0, 2000, 0, 125);
        tftSprite.drawLine(5 + nearMark, barY, 5 + nearMark, barY + barHeight, RED);
        tftSprite.drawLine(5 + farMark, barY, 5 + farMark, barY + barHeight, YELLOW);
        
        // Draw current distance marker
        if (tofDistance < 2000) {
            int distMark = map(tofDistance, 0, 2000, 0, 125);
            tftSprite.fillRect(5 + distMark - 2, barY + 2, 5, barHeight - 4, 
                              tofObjectPresent ? RED : GREEN);
        }
        
        // Controls hint
        tftSprite.setTextColor(0x4208);
        tftSprite.setCursor(5, 220);
        tftSprite.print("[A] Reset [B] Thresh");
        
    } else {
        tftSprite.setTextColor(RED);
        tftSprite.setCursor(10, 80);
        tftSprite.print("TOF not found");
    }
    
    tftSprite.pushSprite(0, 0);
}

void app_scale() {
    tftSprite.fillRect(0, 0, 135, 240, BLACK);
    drawHeader();
    
    // Title
    tftSprite.setTextColor(CYAN);
    tftSprite.drawString("SCALE", 50, 20);
    
    if (scalesInitialized) {
        // Switch to Grove if sensor is on Grove port
        if (scalesBus == &Wire1) switchWire1ToGrove();
        
        // Read weight from scale
        scaleWeight = scales.getWeight();
        int32_t rawADC = scales.getRawADC();
        scaleGapValue = scales.getGapValue();
        
        // Restore Wire1 to internal for AXP192/RTC
        if (scalesBus == &Wire1) switchWire1ToInternal();
        
        // Display weight label
        tftSprite.setTextSize(1);
        tftSprite.setTextColor(WHITE);
        tftSprite.setCursor(40, 45);
        tftSprite.print("Weight:");
        
        // Large weight value
        tftSprite.setTextSize(3);
        
        // Color based on weight
        if (scaleWeight < 0) {
            tftSprite.setTextColor(YELLOW);  // Negative (needs tare)
        } else if (scaleWeight < 10) {
            tftSprite.setTextColor(GREEN);   // Light
        } else if (scaleWeight < 100) {
            tftSprite.setTextColor(CYAN);    // Medium
        } else {
            tftSprite.setTextColor(ORANGE);  // Heavy
        }
        
        // Format and center the weight value
        char weightStr[16];
        if (abs(scaleWeight) < 1000) {
            sprintf(weightStr, "%.1f", scaleWeight);
        } else {
            sprintf(weightStr, "%.0f", scaleWeight);
        }
        int strWidth = strlen(weightStr) * 18;
        tftSprite.setCursor((135 - strWidth) / 2, 70);
        tftSprite.print(weightStr);
        
        // Unit
        tftSprite.setTextSize(2);
        tftSprite.setTextColor(WHITE);
        tftSprite.setCursor(55, 105);
        tftSprite.print("g");
        
        // Show in other units
        tftSprite.setTextSize(1);
        tftSprite.setTextColor(0x7BEF);
        tftSprite.setCursor(20, 135);
        tftSprite.printf("%.3f kg", scaleWeight / 1000.0);
        tftSprite.setCursor(20, 150);
        tftSprite.printf("%.3f oz", scaleWeight / 28.3495);
        tftSprite.setCursor(20, 165);
        tftSprite.printf("%.4f lb", scaleWeight / 453.592);
        
        // Raw ADC value (for debugging/calibration)
        tftSprite.setTextColor(0x4208);
        tftSprite.setCursor(10, 185);
        tftSprite.printf("ADC: %d", rawADC);
        tftSprite.setCursor(10, 198);
        tftSprite.printf("Gap: %.2f", scaleGapValue);
        
        // Controls hint
        tftSprite.setTextColor(0x7BEF);
        tftSprite.setCursor(5, 220);
        tftSprite.print("[A] Tare [B] Gap+/-");
        
    } else {
        tftSprite.setTextColor(RED);
        tftSprite.setCursor(10, 80);
        tftSprite.print("Scale not found");
    }
    
    tftSprite.pushSprite(0, 0);
}

// Brescia, Italy coordinates
#define BRESCIA_LAT 45.5416
#define BRESCIA_LON 10.2118
#define BRESCIA_TZ 1  // CET (UTC+1), adjust for DST manually if needed

// Helper: format minutes since midnight to HH:MM string
void formatTime(int minutes, char* buf) {
    int h = minutes / 60;
    int m = minutes % 60;
    sprintf(buf, "%02d:%02d", h, m);
}

// Helper: format seconds difference to human-readable (e.g., "1m 30s")
void formatSecondsDiff(int seconds, char* buf) {
    bool negative = seconds < 0;
    seconds = abs(seconds);
    int m = seconds / 60;
    int s = seconds % 60;
    if (m > 0 && s > 0) {
        sprintf(buf, "%s%dm %ds", negative ? "-" : "+", m, s);
    } else if (m > 0) {
        sprintf(buf, "%s%dm", negative ? "-" : "+", m);
    } else {
        sprintf(buf, "%s%ds", negative ? "-" : "+", s);
    }
}

// Moon phase calculation (simplified algorithm)
// Returns phase 0-7: 0=New, 1=Waxing Crescent, 2=First Quarter, 3=Waxing Gibbous,
//                    4=Full, 5=Waning Gibbous, 6=Last Quarter, 7=Waning Crescent
// Also returns illumination percentage (0-100)
void getMoonPhase(int year, int month, int day, int* phase, int* illumination) {
    // Calculate Julian Day Number
    int a = (14 - month) / 12;
    int y = year + 4800 - a;
    int m = month + 12 * a - 3;
    long jd = day + (153 * m + 2) / 5 + 365 * y + y / 4 - y / 100 + y / 400 - 32045;
    
    // Days since known new moon (Jan 6, 2000 was a new moon)
    double daysSinceNew = jd - 2451550.1;
    double lunarCycle = 29.530588853;  // Synodic month
    double phase_d = fmod(daysSinceNew, lunarCycle);
    if (phase_d < 0) phase_d += lunarCycle;
    
    // Phase index (0-7)
    *phase = (int)(phase_d / (lunarCycle / 8.0)) % 8;
    
    // Illumination percentage (approximation using cosine)
    double phaseAngle = (phase_d / lunarCycle) * 2.0 * PI;
    *illumination = (int)(50.0 * (1.0 - cos(phaseAngle)));
}

const char* getMoonPhaseName(int phase) {
    switch (phase) {
        case 0: return "New Moon";
        case 1: return "Wax Crescent";
        case 2: return "First Qtr";
        case 3: return "Wax Gibbous";
        case 4: return "Full Moon";
        case 5: return "Wan Gibbous";
        case 6: return "Last Qtr";
        case 7: return "Wan Crescent";
        default: return "Unknown";
    }
}

// Simple moon icon drawing based on phase
void drawMoonIcon(int x, int y, int phase) {
    int r = 12;
    uint16_t moonColor = 0xFFE0;  // Light yellow
    
    // Draw full circle first
    tftSprite.fillCircle(x, y, r, moonColor);
    
    // Draw shadow based on phase
    if (phase == 0) {
        // New moon - all dark
        tftSprite.fillCircle(x, y, r, 0x4208);
    } else if (phase == 4) {
        // Full moon - all lit (already drawn)
    } else if (phase < 4) {
        // Waxing - shadow on left
        int shadowOffset = r - (phase * r / 2);
        tftSprite.fillCircle(x - shadowOffset, y, r, BLACK);
    } else {
        // Waning - shadow on right
        int shadowOffset = r - ((8 - phase) * r / 2);
        tftSprite.fillCircle(x + shadowOffset, y, r, BLACK);
    }
}

// Simple sun icon
void drawSunIcon(int x, int y) {
    int r = 10;
    uint16_t sunColor = YELLOW;
    
    // Draw sun circle
    tftSprite.fillCircle(x, y, r, sunColor);
    
    // Draw rays
    for (int i = 0; i < 8; i++) {
        float angle = i * PI / 4;
        int x1 = x + (r + 3) * cos(angle);
        int y1 = y + (r + 3) * sin(angle);
        int x2 = x + (r + 7) * cos(angle);
        int y2 = y + (r + 7) * sin(angle);
        tftSprite.drawLine(x1, y1, x2, y2, sunColor);
    }
}

void app_sun_moon() {
    tftSprite.fillRect(0, 0, 135, 240, BLACK);
    drawHeader();
    
    // Get current date from RTC
    RTC_DateTypeDef rtcDate;
    M5.Rtc.GetDate(&rtcDate);
    int year = rtcDate.Year;
    int month = rtcDate.Month;
    int day = rtcDate.Date;
    
    // Create SunSet object for Brescia
    SunSet sun;
    sun.setPosition(BRESCIA_LAT, BRESCIA_LON, BRESCIA_TZ);
    sun.setCurrentDate(year, month, day);
    
    // Calculate sun times for today
    int sunrise = (int)sun.calcSunrise();
    int sunset = (int)sun.calcSunset();
    int civilDawn = (int)sun.calcCivilSunrise();
    int civilDusk = (int)sun.calcCivilSunset();
    int nauticalDawn = (int)sun.calcNauticalSunrise();
    int nauticalDusk = (int)sun.calcNauticalSunset();
    
    // Calculate daylight duration today (in seconds)
    int daylightToday = (sunset - sunrise) * 60;
    
    // Calculate for tomorrow
    int tomorrowDay = day + 1;
    int tomorrowMonth = month;
    int tomorrowYear = year;
    // Simple month overflow handling
    int daysInMonth[] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
    // Leap year check
    if ((year % 4 == 0 && year % 100 != 0) || (year % 400 == 0)) {
        daysInMonth[2] = 29;
    }
    if (tomorrowDay > daysInMonth[month]) {
        tomorrowDay = 1;
        tomorrowMonth++;
        if (tomorrowMonth > 12) {
            tomorrowMonth = 1;
            tomorrowYear++;
        }
    }
    
    sun.setCurrentDate(tomorrowYear, tomorrowMonth, tomorrowDay);
    int sunriseTomorrow = (int)sun.calcSunrise();
    int sunsetTomorrow = (int)sun.calcSunset();
    int daylightTomorrow = (sunsetTomorrow - sunriseTomorrow) * 60;
    int daylightDiff = daylightTomorrow - daylightToday;  // In seconds
    
    // Moon phase
    int moonPhase, moonIllum;
    getMoonPhase(year, month, day, &moonPhase, &moonIllum);
    
    // Approximate moonrise/moonset (simplified - actual calculation is complex)
    // Moon rises ~50 minutes later each day, roughly opposite to sun at full moon
    int moonrise = (sunrise + (moonPhase * 90)) % 1440;  // Rough approximation
    int moonset = (moonrise + 720) % 1440;  // ~12 hours later
    
    // === DISPLAY ===
    int yPos = 18;
    
    // Sun section
    drawSunIcon(20, yPos + 15);
    tftSprite.setTextColor(YELLOW);
    tftSprite.setCursor(40, yPos);
    tftSprite.print("SUN");
    yPos += 12;
    
    char timeBuf[8];
    
    // Dawn
    tftSprite.setTextColor(0x7BEF);
    tftSprite.setCursor(40, yPos);
    tftSprite.print("Dawn: ");
    tftSprite.setTextColor(CYAN);
    formatTime(civilDawn, timeBuf);
    tftSprite.print(timeBuf);
    yPos += 11;
    
    // Sunrise
    tftSprite.setTextColor(0x7BEF);
    tftSprite.setCursor(40, yPos);
    tftSprite.print("Rise: ");
    tftSprite.setTextColor(ORANGE);
    formatTime(sunrise, timeBuf);
    tftSprite.print(timeBuf);
    yPos += 11;
    
    // Sunset
    tftSprite.setTextColor(0x7BEF);
    tftSprite.setCursor(40, yPos);
    tftSprite.print("Set:  ");
    tftSprite.setTextColor(ORANGE);
    formatTime(sunset, timeBuf);
    tftSprite.print(timeBuf);
    yPos += 11;
    
    // Dusk
    tftSprite.setTextColor(0x7BEF);
    tftSprite.setCursor(40, yPos);
    tftSprite.print("Dusk: ");
    tftSprite.setTextColor(CYAN);
    formatTime(civilDusk, timeBuf);
    tftSprite.print(timeBuf);
    yPos += 14;
    
    // Daylight duration
    tftSprite.setTextColor(WHITE);
    tftSprite.setCursor(5, yPos);
    int dlHours = (sunset - sunrise) / 60;
    int dlMins = (sunset - sunrise) % 60;
    tftSprite.printf("Daylight: %dh %dm", dlHours, dlMins);
    yPos += 11;
    
    // Tomorrow difference
    char diffBuf[16];
    formatSecondsDiff(daylightDiff, diffBuf);
    tftSprite.setTextColor(daylightDiff >= 0 ? GREEN : RED);
    tftSprite.setCursor(5, yPos);
    tftSprite.printf("Tomorrow: %s", diffBuf);
    yPos += 16;
    
    // Separator line
    tftSprite.drawLine(0, yPos, 135, yPos, 0x4208);
    yPos += 4;
    
    // Moon section
    drawMoonIcon(20, yPos + 15, moonPhase);
    tftSprite.setTextColor(0xFFE0);
    tftSprite.setCursor(40, yPos);
    tftSprite.print("MOON");
    yPos += 12;
    
    // Phase name
    tftSprite.setTextColor(0x7BEF);
    tftSprite.setCursor(40, yPos);
    tftSprite.print(getMoonPhaseName(moonPhase));
    yPos += 11;
    
    // Illumination
    tftSprite.setTextColor(0x7BEF);
    tftSprite.setCursor(40, yPos);
    tftSprite.print("Illum: ");
    tftSprite.setTextColor(WHITE);
    tftSprite.printf("%d%%", moonIllum);
    yPos += 11;
    
    // Moonrise (approximate)
    tftSprite.setTextColor(0x7BEF);
    tftSprite.setCursor(40, yPos);
    tftSprite.print("Rise: ");
    tftSprite.setTextColor(0xC618);
    formatTime(moonrise, timeBuf);
    tftSprite.print(timeBuf);
    tftSprite.setTextColor(0x4208);
    tftSprite.print("~");
    yPos += 11;
    
    // Moonset (approximate)
    tftSprite.setTextColor(0x7BEF);
    tftSprite.setCursor(40, yPos);
    tftSprite.print("Set:  ");
    tftSprite.setTextColor(0xC618);
    formatTime(moonset, timeBuf);
    tftSprite.print(timeBuf);
    tftSprite.setTextColor(0x4208);
    tftSprite.print("~");
    yPos += 14;
    
    // Location info at bottom
    tftSprite.setTextColor(0x4208);
    tftSprite.setCursor(5, 220);
    tftSprite.print("Brescia, IT");
    tftSprite.setCursor(75, 220);
    tftSprite.printf("%02d/%02d/%04d", day, month, year);
    
    tftSprite.pushSprite(0, 0);
}

// Home Assistant MQTT callback
void haMqttCallback(char* topic, byte* payload, unsigned int length) {
    String message;
    for (unsigned int i = 0; i < length; i++) {
        message += (char)payload[i];
    }
    Serial.printf("MQTT [%s]: %s\n", topic, message.c_str());
    
    String topicStr = String(topic);
    
    if (topicStr == HA_MQTT_STATE_TOPIC) {
        haAlarmState = message;
    }
    
    // Check sensor topics
    for (int i = 0; i < HA_SENSOR_COUNT; i++) {
        if (topicStr == haSensorTopics[i]) {
            // "ON" = open, "OFF" = closed (Home Assistant binary_sensor convention)
            haSensorOpen[i] = (message == "ON" || message == "on" || message == "1" || message == "true");
            break;
        }
    }
}

// Home Assistant helper functions
void haConnectWiFi() {
    if (haWiFiEnabled) return;
    
    WiFi.mode(WIFI_STA);
    WiFi.begin(HA_WIFI_SSID, HA_WIFI_PASSWORD);
    haWiFiEnabled = true;
    haState = HA_CONNECTING;
    haConnectStartTime = millis();
    haAlarmState = "unknown";
    Serial.printf("Connecting to WiFi: %s\n", HA_WIFI_SSID);
}

void haConnectMqtt() {
    if (WiFi.status() != WL_CONNECTED) {
        Serial.println("MQTT: WiFi not connected");
        return;
    }
    
    if (!haMqttClient.connected()) {
        Serial.printf("MQTT: Connecting to %s:%d...\n", HA_MQTT_SERVER, HA_MQTT_PORT);
        haMqttClient.setServer(HA_MQTT_SERVER, HA_MQTT_PORT);
        haMqttClient.setCallback(haMqttCallback);
        
        if (haMqttClient.connect("m5stickc-tricorder", HA_MQTT_USER, HA_MQTT_PASSWORD)) {
            Serial.println("MQTT: Connected!");
            haMqttClient.subscribe(HA_MQTT_STATE_TOPIC);
            haMqttClient.subscribe(HA_MQTT_STATUS_TOPIC);
            // Subscribe to all sensor topics
            for (int i = 0; i < HA_SENSOR_COUNT; i++) {
                haMqttClient.subscribe(haSensorTopics[i]);
            }
        } else {
            int rc = haMqttClient.state();
            Serial.printf("MQTT: Failed, rc=%d ", rc);
            switch(rc) {
                case -4: Serial.println("(timeout)"); break;
                case -3: Serial.println("(connection lost)"); break;
                case -2: Serial.println("(connect failed)"); break;
                case -1: Serial.println("(disconnected)"); break;
                case 1: Serial.println("(bad protocol)"); break;
                case 2: Serial.println("(bad client id)"); break;
                case 3: Serial.println("(unavailable)"); break;
                case 4: Serial.println("(bad credentials)"); break;
                case 5: Serial.println("(unauthorized)"); break;
                default: Serial.println("(unknown)"); break;
            }
        }
    }
}

void haDisconnectWiFi() {
    haMqttClient.disconnect();
    WiFi.disconnect(true);
    WiFi.mode(WIFI_OFF);
    haWiFiEnabled = false;
    haState = HA_DISCONNECTED;
    haAlarmState = "unknown";
    Serial.println("WiFi disconnected");
}

bool haArmAlarm() {
    // Try to connect MQTT if not connected
    if (!haMqttClient.connected()) {
        haConnectMqtt();
    }
    
    if (!haMqttClient.connected()) {
        haLastError = "MQTT not connected";
        return false;
    }
    
    if (haMqttClient.publish(HA_MQTT_COMMAND_TOPIC, "ARM_AWAY")) {
        Serial.println("Sent ARM_AWAY command");
        return true;
    }
    haLastError = "Publish failed";
    return false;
}

bool haDisarmAlarm() {
    // Try to connect MQTT if not connected
    if (!haMqttClient.connected()) {
        haConnectMqtt();
    }
    
    if (!haMqttClient.connected()) {
        haLastError = "MQTT not connected";
        return false;
    }
    
    if (haMqttClient.publish(HA_MQTT_COMMAND_TOPIC, "DISARM")) {
        Serial.println("Sent DISARM command");
        return true;
    }
    haLastError = "Publish failed";
    return false;
}

// Flag to track if we've already sent a trigger for the current alarm
bool haAlarmTriggerSent = false;

// Send trigger command to Home Assistant when internal alarm fires
void haTriggerAlarm(const char* source) {
    // Only send if MQTT is connected and we haven't already sent for this alarm
    if (haState != HA_CONNECTED || haAlarmTriggerSent) {
        return;
    }
    
    if (!haMqttClient.connected()) {
        return;
    }
    
    // Only trigger if HA alarm is armed
    if (haAlarmState != "armed_away" && haAlarmState != "armed_home" && 
        haAlarmState != "armed_night" && haAlarmState != "arming") {
        return;
    }
    
    // Send TRIGGER command to the alarm panel (same topic as ARM/DISARM)
    if (haMqttClient.publish(HA_MQTT_COMMAND_TOPIC, "TRIGGER")) {
        Serial.printf("Sent TRIGGER to HA alarm (source: %s)\n", source);
        haAlarmTriggerSent = true;
    }
}

// Reset the trigger flag when alarm is stopped
void haResetTrigger() {
    haAlarmTriggerSent = false;
}

void app_home_assistant() {
    tftSprite.fillRect(0, 0, 135, 240, BLACK);
    drawHeader();
    
    // Title
    tftSprite.setTextColor(CYAN);
    tftSprite.drawString("HOME ASSIST", 30, 20);
    
    int yPos = 45;
    
    // Check WiFi connection status during connecting state
    if (haState == HA_CONNECTING) {
        if (WiFi.status() == WL_CONNECTED) {
            haConnectMqtt();  // Connect to MQTT after WiFi
            haState = HA_CONNECTED;
            Serial.println("WiFi connected!");
            Serial.print("IP: ");
            Serial.println(WiFi.localIP());
        } else if (millis() - haConnectStartTime > HA_CONNECT_TIMEOUT_MS) {
            haState = HA_ERROR;
            haLastError = "Timeout";
            haStatusDisplayTime = millis();
            haDisconnectWiFi();
        }
    }
    
    // Keep MQTT connection alive and process messages
    if (haState == HA_CONNECTED && haMqttClient.connected()) {
        haMqttClient.loop();
    } else if (haState == HA_CONNECTED && !haMqttClient.connected()) {
        haConnectMqtt();  // Reconnect if disconnected
    }
    
    // Clear success/error status after display time
    if ((haState == HA_SUCCESS || haState == HA_ERROR) && 
        millis() - haStatusDisplayTime > HA_STATUS_DISPLAY_MS) {
        if (haWiFiEnabled && WiFi.status() == WL_CONNECTED) {
            haState = HA_CONNECTED;
        } else {
            haState = HA_DISCONNECTED;
        }
    }
    
    // WiFi status section
    tftSprite.setTextColor(0x7BEF);
    tftSprite.setCursor(5, yPos);
    tftSprite.print("WiFi:");
    yPos += 12;
    
    tftSprite.setCursor(10, yPos);
    switch (haState) {
        case HA_DISCONNECTED:
            tftSprite.setTextColor(0x7BEF);
            tftSprite.print("Disconnected");
            break;
        case HA_CONNECTING: {
            tftSprite.setTextColor(YELLOW);
            tftSprite.print("Connecting");
            // Animated dots
            int dots = (millis() / 500) % 4;
            for (int i = 0; i < dots; i++) tftSprite.print(".");
            break;
        }
        case HA_CONNECTED:
            tftSprite.setTextColor(GREEN);
            tftSprite.print("Connected");
            break;
        case HA_SENDING:
            tftSprite.setTextColor(YELLOW);
            tftSprite.print("Sending...");
            break;
        case HA_SUCCESS:
            tftSprite.setTextColor(GREEN);
            tftSprite.print("Success!");
            break;
        case HA_ERROR:
            tftSprite.setTextColor(RED);
            tftSprite.print("Error");
            break;
    }
    yPos += 14;
    
    // Show SSID and MQTT status
    tftSprite.setTextColor(0x7BEF);
    tftSprite.setCursor(10, yPos);
    tftSprite.print("MQTT: ");
    if (haMqttClient.connected()) {
        tftSprite.setTextColor(GREEN);
        tftSprite.print("OK");
    } else {
        tftSprite.setTextColor(0x7BEF);
        tftSprite.print("--");
    }
    yPos += 14;
    
    // Show error message if any
    if (haState == HA_ERROR && haLastError.length() > 0) {
        tftSprite.setTextColor(RED);
        tftSprite.setCursor(10, yPos);
        tftSprite.print(haLastError);
        yPos += 14;
    }
    
    // Separator
    tftSprite.drawLine(0, yPos, 135, yPos, 0x4208);
    yPos += 8;
    
    // Alarm state section
    tftSprite.setTextColor(0x7BEF);
    tftSprite.setCursor(5, yPos);
    tftSprite.print("Alarm State:");
    yPos += 14;
    
    tftSprite.setCursor(10, yPos);
    if (haAlarmState == "armed_away" || haAlarmState == "armed_home" || haAlarmState == "armed_night") {
        tftSprite.setTextColor(RED);
        tftSprite.print("ARMED");
    } else if (haAlarmState == "disarmed") {
        tftSprite.setTextColor(GREEN);
        tftSprite.print("DISARMED");
    } else if (haAlarmState == "pending" || haAlarmState == "arming") {
        tftSprite.setTextColor(YELLOW);
        tftSprite.print("PENDING");
    } else if (haAlarmState == "triggered") {
        tftSprite.setTextColor(RED);
        tftSprite.print("TRIGGERED!");
    } else {
        tftSprite.setTextColor(0x7BEF);
        tftSprite.print(haAlarmState.c_str());
    }
    yPos += 14;
    
    // Separator
    tftSprite.drawLine(0, yPos, 135, yPos, 0x4208);
    yPos += 4;
    
    // Sensors section
    tftSprite.setTextColor(0x7BEF);
    tftSprite.setCursor(5, yPos);
    tftSprite.print("Sensors:");
    yPos += 12;
    
    // Only show sensor status if MQTT is connected
    if (!haMqttClient.connected()) {
        tftSprite.setTextColor(0x7BEF);
        tftSprite.setCursor(10, yPos);
        tftSprite.print("Unknown");
    } else {
        // Count open sensors and build list
        int openCount = 0;
        for (int i = 0; i < HA_SENSOR_COUNT; i++) {
            if (haSensorOpen[i]) openCount++;
        }
        
        if (openCount == 0) {
            tftSprite.setTextColor(GREEN);
            tftSprite.setCursor(10, yPos);
            tftSprite.print("All closed");
        } else {
            tftSprite.setTextColor(RED);
            int displayed = 0;
            for (int i = 0; i < HA_SENSOR_COUNT && displayed < 3; i++) {
                if (haSensorOpen[i]) {
                    tftSprite.setCursor(10, yPos);
                    tftSprite.print(haSensorNames[i]);
                    yPos += 10;
                    displayed++;
                }
            }
            if (openCount > 3) {
                tftSprite.setCursor(10, yPos);
                tftSprite.printf("+%d more", openCount - 3);
            }
        }
    }
    
    // Controls hint at bottom (text-based like other apps)
    tftSprite.setTextColor(0x7BEF);
    tftSprite.setCursor(5, 200);
    if (haState == HA_DISCONNECTED || haState == HA_ERROR) {
        tftSprite.print("[A] Connect");
    } else if (haState == HA_CONNECTING) {
        tftSprite.print("[A] Cancel");
    } else if (haState == HA_CONNECTED) {
        bool isArmed = (haAlarmState == "armed_away" || haAlarmState == "armed_home" || 
                        haAlarmState == "armed_night" || haAlarmState == "arming" || 
                        haAlarmState == "pending" || haAlarmState == "triggered");
        if (isArmed) {
            tftSprite.print("[A] Disarm");
        } else {
            tftSprite.print("[A] Arm");
        }
        tftSprite.setCursor(5, 213);
        tftSprite.print("[B] Disconnect");
    }
    tftSprite.setCursor(5, 226);
    tftSprite.setTextColor(0x4208);
    tftSprite.print("[HOLD] Menu");
    
    tftSprite.pushSprite(0, 0);
}

void app_settings() {
    tftSprite.fillRect(0, 0, 135, 240, BLACK);
    drawHeader();
    
    // Title
    tftSprite.setTextColor(CYAN);
    tftSprite.drawString("SETTINGS", 40, 20);
    
    // Get current RTC time
    RTC_TimeTypeDef rtcTime;
    RTC_DateTypeDef rtcDate;
    M5.Rtc.GetTime(&rtcTime);
    M5.Rtc.GetDate(&rtcDate);
    
    // Draw time/date fields
    const char* fieldNames[] = { "Hour", "Min", "Day", "Month", "Year" };
    
    int startY = 45;
    int fieldHeight = 24;
    
    for (int i = 0; i < SET_FIELD_COUNT; i++) {
        int y = startY + i * fieldHeight;
        
        // Highlight selected field
        if (i == settingsField) {
            if (settingsEditing) {
                tftSprite.fillRect(5, y - 2, 125, 20, 0x03E0);  // Green when editing
            } else {
                tftSprite.fillRect(5, y - 2, 125, 20, 0x001F);  // Blue when selected
            }
        }
        
        // Field name
        tftSprite.setTextColor(i == settingsField ? WHITE : 0x7BEF);
        tftSprite.setCursor(10, y);
        tftSprite.print(fieldNames[i]);
        tftSprite.print(":");
        
        // Field value
        tftSprite.setTextColor(i == settingsField ? WHITE : YELLOW);
        tftSprite.setCursor(70, y);
        if (i == SET_YEAR) {
            tftSprite.printf("%04d", rtcDate.Year);
        } else if (i == SET_HOUR) {
            tftSprite.printf("%02d", rtcTime.Hours);
        } else if (i == SET_MIN) {
            tftSprite.printf("%02d", rtcTime.Minutes);
        } else if (i == SET_DAY) {
            tftSprite.printf("%02d", rtcDate.Date);
        } else if (i == SET_MONTH) {
            tftSprite.printf("%02d", rtcDate.Month);
        }
    }
    
    // Controls hint
    tftSprite.setTextColor(0x7BEF);
    if (settingsEditing) {
        tftSprite.drawString("[B] Next", 40, 195);
        tftSprite.drawString("[PRESS A] Confirm", 15, 210);
    } else {
        tftSprite.drawString("[B] Next", 40, 195);
        tftSprite.drawString("[PRESS A] Edit", 25, 210);
    }
    tftSprite.drawString("[HOLD A] Menu", 30, 225);
    
    tftSprite.pushSprite(0, 0);
}

void drawAppMenu() {
    tftSprite.fillRect(0, 0, 135, 240, BLACK);
    drawHeader();
    
    // Menu title
    tftSprite.setTextColor(CYAN);
    tftSprite.drawString("SELECT APP", 35, 25);
    tftSprite.drawLine(10, 38, 125, 38, 0x7BEF);
    
    // Scrolling menu parameters
    const int itemHeight = 20;
    const int menuStartY = 45;
    const int menuEndY = 155;  // Leave room for status and controls
    const int visibleItems = (menuEndY - menuStartY) / itemHeight;
    
    // Calculate scroll offset to keep selection visible
    static int scrollOffset = 0;
    if (menuSelection < scrollOffset) {
        scrollOffset = menuSelection;
    } else if (menuSelection >= scrollOffset + visibleItems) {
        scrollOffset = menuSelection - visibleItems + 1;
    }
    
    // Draw visible app list items
    for (int i = 0; i < APP_COUNT; i++) {
        int displayIndex = i - scrollOffset;
        if (displayIndex < 0 || displayIndex >= visibleItems) continue;
        
        int y = menuStartY + displayIndex * itemHeight;
        bool enabled = appEnabled[i];
        
        if (i == menuSelection) {
            if (enabled) {
                tftSprite.fillRect(5, y - 2, 125, 18, 0x001F);  // Blue highlight
                tftSprite.setTextColor(WHITE);
            } else {
                tftSprite.fillRect(5, y - 2, 125, 18, 0x2104);  // Dark gray highlight
                tftSprite.setTextColor(0x6B6D);  // Dim gray text
            }
            tftSprite.drawString(">", 10, y);
        } else {
            if (enabled) {
                tftSprite.setTextColor(0x7BEF);  // Normal gray-blue
            } else {
                tftSprite.setTextColor(0x4208);  // Very dim gray
            }
        }
        tftSprite.drawString(appNames[i], 25, y);
    }
    
    // Draw scroll indicators if needed
    if (scrollOffset > 0) {
        tftSprite.setTextColor(CYAN);
        tftSprite.drawString("^", 127, menuStartY);
    }
    if (scrollOffset + visibleItems < APP_COUNT) {
        tftSprite.setTextColor(CYAN);
        tftSprite.drawString("v", 127, menuEndY - itemHeight);
    }
    
    // Separator line
    tftSprite.drawLine(10, 158, 125, 158, 0x7BEF);
    
    // Show status for selected app
    tftSprite.setCursor(15, 165);
    if (appEnabled[menuSelection]) {
        tftSprite.setTextColor(GREEN);
        tftSprite.print("Available");
    } else {
        tftSprite.setTextColor(RED);
        tftSprite.print("Not detected");
    }
    
    // Controls hint
    tftSprite.setTextColor(0x7BEF);
    tftSprite.drawString("[B/ENC] Navigate", 5, 185);
    tftSprite.drawString("[A/ENC BTN] Select", 5, 200);
    tftSprite.setTextColor(0x4208);
    tftSprite.drawString("[HOLD A] Power Off", 5, 215);
    
    tftSprite.pushSprite(0, 0);
}

void handleAppInput() {
    int32_t encoder_value = 0;
    bool enc_btn = true;  // Default to not pressed (active low)
    if (encoderConnected) {
        encoder_value = sensor.getEncoderValue();
        enc_btn = sensor.getButtonStatus();  // active low
    }
    static bool last_enc_btn = true;
    unsigned long now = millis();
    
    // Front button (BtnA) long press detection
    bool btnA_short_press = false;
    bool btnA_long_press = false;
    if (M5.BtnA.isPressed()) {
        if (!btnA_was_pressed) {
            btnA_was_pressed = true;
            btnA_press_start = now;
            btnA_long_triggered = false;
        } else if (!btnA_long_triggered && now - btnA_press_start >= LONG_PRESS_MS) {
            btnA_long_press = true;
            btnA_long_triggered = true;  // Mark long press as handled
        }
    } else {
        // Only register short press if long press wasn't triggered
        if (btnA_was_pressed && !btnA_long_triggered && (now - btnA_press_start < LONG_PRESS_MS)) {
            btnA_short_press = true;
        }
        btnA_was_pressed = false;
        btnA_long_triggered = false;
    }
    
    // Encoder button long press detection (active low: pressed = false)
    bool enc_short_press = false;
    bool enc_long_press = false;
    if (!enc_btn) {  // Button is pressed
        if (!enc_btn_was_pressed) {
            enc_btn_was_pressed = true;
            enc_btn_press_start = now;
            enc_long_triggered = false;
        } else if (!enc_long_triggered && now - enc_btn_press_start >= LONG_PRESS_MS) {
            enc_long_press = true;
            enc_long_triggered = true;  // Mark long press as handled
        }
    } else {
        // Only register short press if long press wasn't triggered
        if (enc_btn_was_pressed && !enc_long_triggered && (now - enc_btn_press_start < LONG_PRESS_MS)) {
            enc_short_press = true;
        }
        enc_btn_was_pressed = false;
        enc_long_triggered = false;
    }
    last_enc_btn = enc_btn;
    
    if (appState == APP_MENU) {
        // Helper lambda to find next enabled app
        auto findNextEnabled = [](int current, int direction) -> int {
            int next = current;
            for (int i = 0; i < APP_COUNT; i++) {
                next = (next + direction + APP_COUNT) % APP_COUNT;
                if (appEnabled[next]) return next;
            }
            return current;  // No enabled apps found, stay put
        };
        
        // Menu navigation with encoder
        int32_t encoderDelta = encoder_value - menuEncoderBase;
        if (abs(encoderDelta) >= 4) {  // Threshold for one step
            if (encoderDelta > 0) {
                menuSelection = findNextEnabled(menuSelection, 1);
            } else {
                menuSelection = findNextEnabled(menuSelection, -1);
            }
            menuEncoderBase = encoder_value;
        }
        
        // Side button for navigation
        if (M5.BtnB.wasPressed()) {
            menuSelection = findNextEnabled(menuSelection, 1);
        }
        
        // Select with short press of front button or encoder button (only if app is enabled)
        if (btnA_short_press || enc_short_press) {
            if (appEnabled[menuSelection]) {
                if (menuSelection == APP_POWER_OFF) {
                    // Power off the device
                    tftSprite.fillRect(0, 0, 135, 240, BLACK);
                    tftSprite.setTextColor(WHITE);
                    tftSprite.drawString("Powering off...", 20, 110);
                    tftSprite.pushSprite(0, 0);
                    delay(500);
                    M5.Axp.PowerOff();
                } else {
                    currentApp = (AppID)menuSelection;
                    appState = APP_RUNNING;
                    // Reset encoder base for apps that use it
                    timerEncoderBase = encoder_value;
                }
            }
        }
        
        // Long press A in menu powers off the device
        if (btnA_long_press || enc_long_press) {
            tftSprite.fillRect(0, 0, 135, 240, BLACK);
            tftSprite.setTextColor(WHITE);
            tftSprite.drawString("Powering off...", 20, 110);
            tftSprite.pushSprite(0, 0);
            delay(500);
            M5.Axp.PowerOff();
        }
    } else {
        // Long press opens menu (but check for special app states first)
        if (btnA_long_press || enc_long_press) {
            // Special handling for IR Remote file/command selection - go back instead of menu
            if (currentApp == APP_IR_REMOTE) {
                if (irFileState == IRFILE_SELECT_CMD) {
                    // Go back to file list
                    irFileState = IRFILE_SELECT_FILE;
                    return;
                } else if (irFileState == IRFILE_SELECT_FILE) {
                    // Go back to main IR list
                    irFileState = IRFILE_NONE;
                    return;
                }
            }
            // Special handling for Web Files file list - go back to main
            if (currentApp == APP_WEB_FILES && webFilesAppState == WEBFILES_LIST) {
                webFilesAppState = WEBFILES_MAIN;
                return;
            }
            // Default: open app menu
            appState = APP_MENU;
            menuSelection = currentApp;
            menuEncoderBase = encoder_value;
            return;
        }
        
        // App-specific input handling
        if (currentApp == APP_AIR_QUALITY) {
            // Short press A: Arm/disarm air quality alarm
            if (btnA_short_press || enc_short_press) {
                if (airQualityAlarmArmed) {
                    // Disarm
                    airQualityAlarmArmed = false;
                    airQualityAlarmTriggered = false;
                    stopAlarm();
                } else {
                    // Arm
                    airQualityAlarmArmed = true;
                    airQualityAlarmTriggered = false;
                }
            }
            
            // Long press side button (B) to clear history data
            static unsigned long airQualityBtnB_press_start = 0;
            static bool airQualityBtnB_long_triggered = false;
            
            if (M5.BtnB.isPressed()) {
                if (airQualityBtnB_press_start == 0) {
                    airQualityBtnB_press_start = millis();
                    airQualityBtnB_long_triggered = false;
                } else if (!airQualityBtnB_long_triggered && millis() - airQualityBtnB_press_start >= 2000) {
                    // Long press (2 sec) - Clear all history data
                    airQualityBtnB_long_triggered = true;
                    clearHistory();
                    // Show confirmation
                    tftSprite.fillRect(0, 60, 135, 80, BLACK);
                    tftSprite.setTextColor(GREEN);
                    tftSprite.drawString("DATA CLEARED", 25, 100);
                    tftSprite.pushSprite(0, 0);
                    delay(1000);
                }
            } else {
                airQualityBtnB_press_start = 0;
                airQualityBtnB_long_triggered = false;
            }
        }
        else if (currentApp == APP_STOPWATCH) {
            // Short press toggles stopwatch
            if (btnA_short_press || enc_short_press) {
                if (stopwatchRunning) {
                    stopwatchElapsed += millis() - stopwatchStartTime;
                    stopwatchRunning = false;
                } else {
                    stopwatchStartTime = millis();
                    stopwatchRunning = true;
                }
            }
            // Side button resets stopwatch
            if (M5.BtnB.wasPressed()) {
                stopwatchRunning = false;
                stopwatchElapsed = 0;
            }
        }
        else if (currentApp == APP_TIMER) {
            // Timer time adjustment with encoder - variable step sizes
            int32_t encoderDelta = encoder_value - timerEncoderBase;
            if (timerState == TIMER_SETTING && abs(encoderDelta) >= 2) {
                int32_t direction = (encoderDelta > 0) ? 1 : -1;
                
                // Determine step size based on current duration and direction
                // When decreasing, use step size for the lower bracket
                int32_t stepMs;
                if (direction > 0) {
                    // Increasing: use current duration bracket
                    if (timerDuration < 60000) {
                        stepMs = 5000;        // 5 sec steps under 1 min
                    } else if (timerDuration < 600000) {
                        stepMs = 60000;       // 1 min steps under 10 min
                    } else if (timerDuration < 3600000) {
                        stepMs = 300000;      // 5 min steps under 1 hour
                    } else {
                        stepMs = 1800000;     // 30 min steps over 1 hour
                    }
                } else {
                    // Decreasing: use lower bracket step size at boundaries
                    if (timerDuration <= 60000) {
                        stepMs = 5000;        // 5 sec steps at/under 1 min
                    } else if (timerDuration <= 600000) {
                        stepMs = 60000;       // 1 min steps at/under 10 min
                    } else if (timerDuration <= 3600000) {
                        stepMs = 300000;      // 5 min steps at/under 1 hour
                    } else {
                        stepMs = 1800000;     // 30 min steps over 1 hour
                    }
                }
                
                int32_t newDuration = timerDuration + (direction * stepMs);
                
                // Clamp to valid range (5 sec to 24 hours)
                if (newDuration >= 5000 && newDuration <= 86400000) {
                    timerDuration = newDuration;
                }
                timerEncoderBase = encoder_value;
            }
            
            // Side buttons adjust time (BtnA increase, BtnB decrease)
            if (timerState == TIMER_SETTING) {
                if (M5.BtnB.wasPressed()) {
                    if (timerDuration >= 70000) timerDuration -= 60000;  // -1 min
                }
            } else if (timerState == TIMER_RUNNING || timerState == TIMER_PAUSED) {
                // Side button resets timer
                if (M5.BtnB.wasPressed()) {
                    timerState = TIMER_SETTING;
                }
            }
            
            // Short press action depends on state
            if (btnA_short_press || enc_short_press) {
                switch (timerState) {
                    case TIMER_SETTING:
                        // Start the timer
                        timerRemaining = timerDuration;
                        timerStartTime = millis();
                        timerState = TIMER_RUNNING;
                        break;
                    case TIMER_RUNNING:
                        // Pause
                        timerRemaining -= (millis() - timerStartTime);
                        timerState = TIMER_PAUSED;
                        break;
                    case TIMER_PAUSED:
                        // Resume
                        timerStartTime = millis();
                        timerState = TIMER_RUNNING;
                        break;
                    case TIMER_FINISHED:
                        // Stop alarm and reset to setting
                        stopAlarm();
                        haResetTrigger();
                        timerState = TIMER_SETTING;
                        break;
                }
            }
            
            // Check if timer finished
            if (timerState == TIMER_RUNNING) {
                unsigned long elapsed = millis() - timerStartTime;
                if (elapsed >= timerRemaining) {
                    timerState = TIMER_FINISHED;
                    lastAlarmTone = 0;  // Start alarm immediately
                    haTriggerAlarm("timer");
                }
            }
            
            // Play alarm when finished
            if (timerState == TIMER_FINISHED) {
                triggerAlarm();
            }
        }
        else if (currentApp == APP_MOTION) {
            // Short press to arm/disarm
            if (btnA_short_press || enc_short_press) {
                motionArmed = !motionArmed;
                motionDetected = false;
                if (!motionArmed) {
                    stopAlarm();  // Stop alarm when disarming
                    haResetTrigger();
                }
            }
            
            // Play alarm when motion detected and armed
            if (motionArmed && motionDetected) {
                haTriggerAlarm("motion");  // Only sends once due to haAlarmTriggerSent flag
                triggerAlarm();
            } else if (currentApp == APP_MOTION && !motionDetected) {
                stopAlarm();
                haResetTrigger();
            }
        }
        else if (currentApp == APP_IR_REMOTE) {
            // Handle file selection states first
            if (irFileState == IRFILE_SELECT_FILE) {
                // File selection mode
                if (btnA_short_press || enc_short_press) {
                    if (irFilesCount > 0) {
                        // Load selected file
                        if (irFileLoad(irFilesList[irFileSelectedFile])) {
                            irFileSelectedCmd = 0;
                            irFileState = IRFILE_SELECT_CMD;
                        }
                    }
                }
                // Side button: Scroll to next file
                if (M5.BtnB.wasPressed()) {
                    if (irFilesCount > 0) {
                        irFileSelectedFile = (irFileSelectedFile + 1) % irFilesCount;
                    }
                }
            }
            else if (irFileState == IRFILE_SELECT_CMD) {
                // Command selection from file
                if (btnA_short_press || enc_short_press) {
                    if (irFileCommandCount > 0) {
                        irFileSendCommand(irFileSelectedCmd);
                        Serial.printf("Sent file IR command: %s\n", irFileCommands[irFileSelectedCmd].name);
                    }
                }
                // Side button: Scroll to next command
                if (M5.BtnB.wasPressed()) {
                    if (irFileCommandCount > 0) {
                        irFileSelectedCmd = (irFileSelectedCmd + 1) % irFileCommandCount;
                    }
                }
            }
            else if (irAppState == IR_LIST) {
                // Short press: Send command or browse files
                if (btnA_short_press || enc_short_press) {
                    if (irSelectedCmd < irCommandCount) {
                        // Find the actual command index
                        int cmdIdx = -1;
                        int count = 0;
                        for (int j = 0; j < IR_MAX_COMMANDS; j++) {
                            if (irCommands[j].used) {
                                if (count == irSelectedCmd) {
                                    cmdIdx = j;
                                    break;
                                }
                                count++;
                            }
                        }
                        if (cmdIdx >= 0) {
                            sendIRCommand(cmdIdx);
                            Serial.printf("Sent IR command: %s\n", irCommands[cmdIdx].name);
                        }
                    } else {
                        // Load .ir file - scan for files and enter file selection
                        irFilesScanDirectory();
                        irFileSelectedFile = 0;
                        irFileState = IRFILE_SELECT_FILE;
                    }
                }
                
                // Side button: Scroll to next item
                if (M5.BtnB.wasPressed()) {
                    int totalItems = irCommandCount + 1;  // +1 for "Load File"
                    irSelectedCmd = (irSelectedCmd + 1) % totalItems;
                }
            }
        }
        else if (currentApp == APP_LEVEL) {
            // Encoder adjusts alarm threshold
            static int32_t levelEncoderBase = 0;
            static bool levelEncoderInit = false;
            if (!levelEncoderInit) {
                levelEncoderBase = encoder_value;
                levelEncoderInit = true;
            }
            
            int32_t encDelta = encoder_value - levelEncoderBase;
            if (abs(encDelta) >= 4) {
                int steps = encDelta / 4;
                levelAlarmThreshold += steps;
                levelAlarmThreshold = constrain(levelAlarmThreshold, 1.0, 45.0);
                levelEncoderBase = encoder_value;
            }
            
            // Short press: Arm/disarm alarm (captures current angles as reference)
            if (btnA_short_press || enc_short_press) {
                if (levelAlarmArmed) {
                    // Disarm
                    levelAlarmArmed = false;
                    levelAlarmTriggered = false;
                    stopAlarm();
                    haResetTrigger();
                } else {
                    // Arm - capture current angles as reference
                    levelRefPitch = levelPitch;
                    levelRefRoll = levelRoll;
                    levelRefYaw = levelYaw;
                    levelAlarmArmed = true;
                    levelAlarmTriggered = false;
                }
            }
            
            // Side button: Reset yaw to zero / stop alarm
            if (M5.BtnB.wasPressed()) {
                if (levelAlarmTriggered) {
                    levelAlarmTriggered = false;
                    stopAlarm();
                    haResetTrigger();
                }
            }
            
            // Play alarm when triggered
            if (levelAlarmTriggered) {
                haTriggerAlarm("level");  // Only sends once due to haAlarmTriggerSent flag
                triggerAlarm();
            }
        }
        else if (currentApp == APP_TOF_COUNTER) {
            // Short press Button A: Reset counter
            if (btnA_short_press) {
                tofCount = 0;
                tofObjectPresent = false;
                tofMinDistance = 8190;
                tofMaxDistance = 0;
            }
            
            // Side button (B): Cycle through near threshold presets
            // Note: Encoder hat can't be used with TOF hat, so buttons only
            if (M5.BtnB.wasPressed()) {
                // Cycle near threshold: 100 -> 200 -> 300 -> 500 -> 100...
                if (tofThresholdNear < 150) {
                    tofThresholdNear = 200;
                } else if (tofThresholdNear < 250) {
                    tofThresholdNear = 300;
                } else if (tofThresholdNear < 400) {
                    tofThresholdNear = 500;
                } else {
                    tofThresholdNear = 100;
                }
                // Far threshold is always near + 200mm
                tofThresholdFar = tofThresholdNear + 200;
            }
        }
        else if (currentApp == APP_SCALE) {
            // Short press Button A: Tare (set offset/zero)
            if (btnA_short_press) {
                if (scalesInitialized) {
                    if (scalesBus == &Wire1) switchWire1ToGrove();
                    scales.setOffset();
                    // Flash LED to confirm
                    scales.setLEDColor(0x100000);  // Red flash
                    delay(100);
                    scales.setLEDColor(0x001000);  // Back to green
                    if (scalesBus == &Wire1) switchWire1ToInternal();
                }
            }
            
            // Side button (B): Adjust gap value (calibration)
            // Short press increases, long press decreases
            static unsigned long scaleBtnB_press_start = 0;
            static bool scaleBtnB_long_triggered = false;
            
            if (M5.BtnB.isPressed()) {
                if (scaleBtnB_press_start == 0) {
                    scaleBtnB_press_start = millis();
                    scaleBtnB_long_triggered = false;
                } else if (!scaleBtnB_long_triggered && millis() - scaleBtnB_press_start >= 500) {
                    // Long press - decrease gap
                    scaleBtnB_long_triggered = true;
                    if (scalesInitialized) {
                        scaleGapValue -= 0.1;
                        if (scalesBus == &Wire1) switchWire1ToGrove();
                        scales.setGapValue(scaleGapValue);
                        if (scalesBus == &Wire1) switchWire1ToInternal();
                    }
                }
            } else {
                if (scaleBtnB_press_start > 0 && !scaleBtnB_long_triggered) {
                    // Short press - increase gap
                    if (scalesInitialized) {
                        scaleGapValue += 0.1;
                        if (scalesBus == &Wire1) switchWire1ToGrove();
                        scales.setGapValue(scaleGapValue);
                        if (scalesBus == &Wire1) switchWire1ToInternal();
                    }
                }
                scaleBtnB_press_start = 0;
                scaleBtnB_long_triggered = false;
            }
        }
        else if (currentApp == APP_SETTINGS) {
            // Get current RTC values for editing
            RTC_TimeTypeDef rtcTime;
            RTC_DateTypeDef rtcDate;
            M5.Rtc.GetTime(&rtcTime);
            M5.Rtc.GetDate(&rtcDate);
            
            if (settingsEditing) {
                // Encoder adjusts the selected field value
                int32_t encDelta = encoder_value - settingsEncoderBase;
                if (abs(encDelta) >= 2) {
                    int direction = (encDelta > 0) ? 1 : -1;
                    
                    switch (settingsField) {
                        case SET_HOUR:
                            rtcTime.Hours = (rtcTime.Hours + direction + 24) % 24;
                            M5.Rtc.SetTime(&rtcTime);
                            break;
                        case SET_MIN:
                            rtcTime.Minutes = (rtcTime.Minutes + direction + 60) % 60;
                            M5.Rtc.SetTime(&rtcTime);
                            break;
                        case SET_DAY:
                            rtcDate.Date = constrain(rtcDate.Date + direction, 1, 31);
                            M5.Rtc.SetDate(&rtcDate);
                            break;
                        case SET_MONTH:
                            rtcDate.Month = (rtcDate.Month - 1 + direction + 12) % 12 + 1;
                            M5.Rtc.SetDate(&rtcDate);
                            break;
                        case SET_YEAR:
                            rtcDate.Year = constrain(rtcDate.Year + direction, 2020, 2099);
                            M5.Rtc.SetDate(&rtcDate);
                            break;
                        default:
                            break;
                    }
                    settingsEncoderBase = encoder_value;
                }
                
                // Short press confirms and exits edit mode
                if (btnA_short_press || enc_short_press) {
                    settingsEditing = false;
                }
                
                // B button increments value by 1, wraps to 0 at max
                if (M5.BtnB.wasPressed()) {
                    switch (settingsField) {
                        case SET_HOUR:
                            rtcTime.Hours = (rtcTime.Hours + 1) % 24;
                            M5.Rtc.SetTime(&rtcTime);
                            break;
                        case SET_MIN:
                            rtcTime.Minutes = (rtcTime.Minutes + 1) % 60;
                            M5.Rtc.SetTime(&rtcTime);
                            break;
                        case SET_DAY:
                            rtcDate.Date = (rtcDate.Date % 31) + 1;
                            M5.Rtc.SetDate(&rtcDate);
                            break;
                        case SET_MONTH:
                            rtcDate.Month = (rtcDate.Month % 12) + 1;
                            M5.Rtc.SetDate(&rtcDate);
                            break;
                        case SET_YEAR:
                            if (rtcDate.Year >= 2099) {
                                rtcDate.Year = 2020;
                            } else {
                                rtcDate.Year++;
                            }
                            M5.Rtc.SetDate(&rtcDate);
                            break;
                        default:
                            break;
                    }
                }
            } else {
                // Encoder navigates between fields
                int32_t encDelta = encoder_value - settingsEncoderBase;
                if (abs(encDelta) >= 4) {
                    if (encDelta > 0) {
                        settingsField = (SettingsField)((settingsField + 1) % SET_FIELD_COUNT);
                    } else {
                        settingsField = (SettingsField)((settingsField - 1 + SET_FIELD_COUNT) % SET_FIELD_COUNT);
                    }
                    settingsEncoderBase = encoder_value;
                }
                
                // Side button also navigates
                if (M5.BtnB.wasPressed()) {
                    settingsField = (SettingsField)((settingsField + 1) % SET_FIELD_COUNT);
                }
                
                // Short press enters edit mode
                if (btnA_short_press || enc_short_press) {
                    settingsEditing = true;
                    settingsEncoderBase = encoder_value;
                }
            }
        }
        else if (currentApp == APP_WEB_FILES) {
            // Web Files app input handling
            if (webFilesAppState == WEBFILES_WIFI_ON) {
                // WiFi is active - A button stops it
                if (btnA_short_press || enc_short_press) {
                    webFilesStopWiFi();
                    webFilesAppState = WEBFILES_MAIN;
                }
            }
            else if (webFilesAppState == WEBFILES_LIST) {
                // File list view
                // Encoder navigation
                int32_t encDelta = encoder_value - settingsEncoderBase;
                if (abs(encDelta) >= 2) {
                    int steps = encDelta / 2;
                    webFilesSelectedFile += steps;
                    if (webFilesSelectedFile < 0) webFilesSelectedFile = webFilesCount - 1;
                    if (webFilesSelectedFile >= webFilesCount) webFilesSelectedFile = 0;
                    settingsEncoderBase = encoder_value;
                }
                
                // Side button: Scroll to next file
                if (M5.BtnB.wasPressed()) {
                    if (webFilesCount > 0) {
                        webFilesSelectedFile = (webFilesSelectedFile + 1) % webFilesCount;
                    }
                }
                
                // A button: Delete selected file
                if (btnA_short_press || enc_short_press) {
                    if (webFilesCount > 0 && webFilesSelectedFile < webFilesCount) {
                        webFilesDeleteFile(webFilesList[webFilesSelectedFile]);
                        webFilesScanDirectory();
                        if (webFilesSelectedFile >= webFilesCount && webFilesCount > 0) {
                            webFilesSelectedFile = webFilesCount - 1;
                        }
                    }
                    if (webFilesCount == 0) {
                        webFilesAppState = WEBFILES_MAIN;
                    }
                }
            }
            else {
                // Main menu
                if (btnA_short_press || enc_short_press) {
                    // Start WiFi AP
                    webFilesStartWiFi();
                    webFilesAppState = WEBFILES_WIFI_ON;
                }
                if (M5.BtnB.wasPressed()) {
                    // View files
                    webFilesScanDirectory();
                    webFilesSelectedFile = 0;
                    settingsEncoderBase = encoder_value;
                    webFilesAppState = WEBFILES_LIST;
                }
            }
        }
        else if (currentApp == APP_HOME_ASSISTANT) {
            // Home Assistant app input handling
            // A button: Connect / Cancel / Toggle ARM-DISARM based on alarm state
            if (btnA_short_press || enc_short_press) {
                if (haState == HA_DISCONNECTED || haState == HA_ERROR) {
                    // Connect to WiFi
                    haConnectWiFi();
                } else if (haState == HA_CONNECTING) {
                    // Cancel connection
                    haDisconnectWiFi();
                } else if (haState == HA_CONNECTED) {
                    // Toggle ARM/DISARM based on current alarm state
                    haState = HA_SENDING;
                    bool isArmed = (haAlarmState == "armed_away" || haAlarmState == "armed_home" || 
                                    haAlarmState == "armed_night" || haAlarmState == "arming" || 
                                    haAlarmState == "pending" || haAlarmState == "triggered");
                    if (isArmed) {
                        // Alarm is armed - DISARM it
                        if (haDisarmAlarm()) {
                            haState = HA_SUCCESS;
                            haStatusDisplayTime = millis();
                        } else {
                            haState = HA_ERROR;
                            haStatusDisplayTime = millis();
                        }
                    } else {
                        // Alarm is disarmed or unknown - ARM it
                        // First check if any sensors are open
                        int openCount = 0;
                        for (int i = 0; i < HA_SENSOR_COUNT; i++) {
                            if (haSensorOpen[i]) openCount++;
                        }
                        if (openCount > 0) {
                            // Cannot arm - sensors are open
                            haState = HA_ERROR;
                            haLastError = "Close sensors first";
                            haStatusDisplayTime = millis();
                        } else if (haArmAlarm()) {
                            haState = HA_SUCCESS;
                            haStatusDisplayTime = millis();
                        } else {
                            haState = HA_ERROR;
                            haStatusDisplayTime = millis();
                        }
                    }
                }
            }
            
            // B button: Disconnect WiFi when connected
            if (M5.BtnB.wasPressed()) {
                if (haState == HA_CONNECTED || haState == HA_SUCCESS) {
                    haDisconnectWiFi();
                }
            }
        }
    }
}

void renderCurrentApp() {
    if (appState == APP_MENU) {
        drawAppMenu();
    } else {
        switch (currentApp) {
            case APP_AIR_QUALITY:
                app_air_quality();
                break;
            case APP_STOPWATCH:
                app_stopwatch();
                break;
            case APP_TIMER:
                app_timer();
                break;
            case APP_MOTION:
                app_motion();
                break;
            case APP_NCIR:
                app_ncir();
                break;
            case APP_HEARTRATE:
                app_heartrate();
                break;
            case APP_IR_REMOTE:
                app_ir_remote();
                break;
            case APP_LEVEL:
                app_level();
                break;
            case APP_DISTANCE:
                app_distance();
                break;
            case APP_TOF_COUNTER:
                app_tof_counter();
                break;
            case APP_SCALE:
                app_scale();
                break;
            case APP_WEB_FILES:
                app_web_files();
                break;
            case APP_SUN_MOON:
                app_sun_moon();
                break;
            case APP_HOME_ASSISTANT:
                app_home_assistant();
                break;
            case APP_SETTINGS:
                app_settings();
                break;
            default:
                app_air_quality();
                break;
        }
    }
}

void get_inc_value(void) {
    int32_t inc_value = sensor.getIncrementValue();
    Serial.printf("Inc:%d", inc_value);
}

void setup() {
    M5.begin();  // Init M5Stack.  初始化M5Stack
    
    // Initialize buzzer on GPIO 2
    buzzerInit();
    
    // Initialize internal LED
    ledInit();
    
    // Test buzzer at startup
    buzzerTone(1000);
    delay(100);
    buzzerMute();
    
    // Initialize IR sender
    IrSender.begin(IR_SEND_PIN);
    
    // Initialize LittleFS for file storage
    webFilesInit();
    
    // Load saved IR commands from flash
    loadIRCommands();
    Serial.printf("Loaded %d IR commands from flash\n", irCommandCount);
    
    // Initialize encoder on its Qwiic port (GPIO 0/26)
    // This reconfigures Wire to use those pins
    // Note: GPIO 0 is a strapping pin, but encoder library handles it
    encoderConnected = sensor.begin(&Wire, MINIENCODERC_ADDR, QWIIC_SDA, QWIIC_SCL, 100000UL);
    if (encoderConnected) {
        Serial.println("Encoder connected on Wire (GPIO 0/26)");
    } else {
        Serial.println("Encoder NOT connected - some features disabled");
    }
    
    // Temporarily configure Wire1 for Grove port (32/33) to scan for external sensors
    // IMPORTANT: Wire1 is normally used by M5StickC for internal AXP192/RTC on GPIO 21/22
    // We will restore it after sensor detection
    Wire1.end();
    Wire1.begin(GROVE_SDA, GROVE_SCL, 100000UL);
    currentWire1Mode = WIRE1_GROVE;
    delay(50);  // Allow I2C to stabilize
    
    // Detect connected sensors and enable corresponding apps
    Serial.println("Detecting connected sensors on both I2C buses...");
    Serial.println("  Wire  = Encoder Qwiic port (GPIO 0/26)");
    Serial.println("  Wire1 = Grove port (GPIO 32/33) - temporary for detection");
    
    // Stopwatch and Timer are always available (no hardware needed)
    appEnabled[APP_STOPWATCH] = true;
    appEnabled[APP_TIMER] = true;
    
    // Initialize IMU for 3D Level app (built-in MPU6886)
    M5.Imu.Init();
    appEnabled[APP_LEVEL] = true;
    Serial.println("  IMU (MPU6886) initialized -> 3D Level enabled");
    
    // Check for CO2 sensor (SCD4x) on both buses at address 0x62
    // Wire = Qwiic port (encoder), Wire1 = Grove port (temporary)
    Wire.beginTransmission(SCD4X_I2C_ADDR);
    if (Wire.endTransmission() == 0) {
        scd4xBus = &Wire;
        appEnabled[APP_AIR_QUALITY] = true;
        Serial.println("  CO2 sensor (SCD4x) detected on Wire (Qwiic) at 0x62 -> Air Quality enabled");
    } else {
        Wire1.beginTransmission(SCD4X_I2C_ADDR);
        if (Wire1.endTransmission() == 0) {
            scd4xBus = &Wire1;
            groveUsedForI2C = true;
            appEnabled[APP_AIR_QUALITY] = true;
            Serial.println("  CO2 sensor (SCD4x) detected on Wire1 (Grove) at 0x62 -> Air Quality enabled");
        } else {
            scd4xBus = NULL;
            Serial.println("  CO2 sensor (SCD4x) not detected on either bus");
        }
    }
    
    // Check for SGP30 TVOC/eCO2 sensor on both buses at address 0x58
    Wire.beginTransmission(SGP30_I2C_ADDR);
    if (Wire.endTransmission() == 0) {
        sgp30Bus = &Wire;
        appEnabled[APP_AIR_QUALITY] = true;
        Serial.println("  TVOC/eCO2 sensor (SGP30) detected on Wire (Qwiic) at 0x58 -> Air Quality enabled");
    } else {
        Wire1.beginTransmission(SGP30_I2C_ADDR);
        if (Wire1.endTransmission() == 0) {
            sgp30Bus = &Wire1;
            groveUsedForI2C = true;
            appEnabled[APP_AIR_QUALITY] = true;
            Serial.println("  TVOC/eCO2 sensor (SGP30) detected on Wire1 (Grove) at 0x58 -> Air Quality enabled");
        } else {
            sgp30Bus = NULL;
            Serial.println("  TVOC/eCO2 sensor (SGP30) not detected on either bus");
        }
    }
    
    // If neither CO2 nor SGP30 detected, disable Air Quality (ENV Pro will enable it later if present)
    if (scd4xBus == NULL && sgp30Bus == NULL) {
        appEnabled[APP_AIR_QUALITY] = false;
    }
    
    // Check for NCIR sensor (MLX90614) on both buses at address 0x5A
    Wire.beginTransmission(MLX90614_I2C_ADDR);
    if (Wire.endTransmission() == 0) {
        if (mlx.begin(MLX90614_I2C_ADDR, &Wire)) {
            mlxBus = &Wire;
            appEnabled[APP_NCIR] = true;
            Serial.println("  NCIR sensor (MLX90614) detected on Wire (Qwiic) at 0x5A -> NCIR Temp enabled");
        } else {
            appEnabled[APP_NCIR] = false;
            Serial.println("  NCIR sensor found on Wire but init failed -> NCIR Temp disabled");
        }
    } else {
        Wire1.beginTransmission(MLX90614_I2C_ADDR);
        if (Wire1.endTransmission() == 0) {
            if (mlx.begin(MLX90614_I2C_ADDR, &Wire1)) {
                mlxBus = &Wire1;
                groveUsedForI2C = true;
                appEnabled[APP_NCIR] = true;
                Serial.println("  NCIR sensor (MLX90614) detected on Wire1 (Grove) at 0x5A -> NCIR Temp enabled");
            } else {
                appEnabled[APP_NCIR] = false;
                Serial.println("  NCIR sensor found on Wire1 but init failed -> NCIR Temp disabled");
            }
        } else {
            mlxBus = NULL;
            appEnabled[APP_NCIR] = false;
            Serial.println("  NCIR sensor not detected on either bus -> NCIR Temp disabled");
        }
    }
    
    // Check for Heart Rate sensor (MAX30102) on both buses at address 0x57
    Wire.beginTransmission(MAX30102_I2C_ADDR);
    if (Wire.endTransmission() == 0) {
        if (heartRateSensor.begin(Wire, I2C_SPEED_FAST)) {
            heartRateBus = &Wire;
            heartRateSensor.setup();
            appEnabled[APP_HEARTRATE] = true;
            Serial.println("  Heart Rate sensor (MAX30102) detected on Wire (Qwiic) at 0x57 -> Heart Rate enabled");
        } else {
            appEnabled[APP_HEARTRATE] = false;
            Serial.println("  Heart Rate sensor found on Wire but init failed -> Heart Rate disabled");
        }
    } else {
        Wire1.beginTransmission(MAX30102_I2C_ADDR);
        if (Wire1.endTransmission() == 0) {
            if (heartRateSensor.begin(Wire1, I2C_SPEED_FAST)) {
                heartRateBus = &Wire1;
                groveUsedForI2C = true;
                heartRateSensor.setup();
                appEnabled[APP_HEARTRATE] = true;
                Serial.println("  Heart Rate sensor (MAX30102) detected on Wire1 (Grove) at 0x57 -> Heart Rate enabled");
            } else {
                appEnabled[APP_HEARTRATE] = false;
                Serial.println("  Heart Rate sensor found on Wire1 but init failed -> Heart Rate disabled");
            }
        } else {
            heartRateBus = NULL;
            appEnabled[APP_HEARTRATE] = false;
            Serial.println("  Heart Rate sensor not detected on either bus -> Heart Rate disabled");
        }
    }
    
    // Check for TOF sensor (VL53L0X) on both buses at address 0x29
    Wire.beginTransmission(VL53L0X_I2C_ADDR);
    if (Wire.endTransmission() == 0) {
        tofSensor.setBus(&Wire);
        tofSensor.setTimeout(500);
        if (tofSensor.init()) {
            tofBus = &Wire;
            tofSensor.startContinuous();
            tofInitialized = true;
            appEnabled[APP_DISTANCE] = true;
            appEnabled[APP_TOF_COUNTER] = true;
            Serial.println("  TOF sensor (VL53L0X) detected on Wire (Qwiic) at 0x29 -> Distance & TOF Counter enabled");
        } else {
            appEnabled[APP_DISTANCE] = false;
            appEnabled[APP_TOF_COUNTER] = false;
            Serial.println("  TOF sensor found on Wire but init failed -> Distance & TOF Counter disabled");
        }
    } else {
        Wire1.beginTransmission(VL53L0X_I2C_ADDR);
        if (Wire1.endTransmission() == 0) {
            tofSensor.setBus(&Wire1);
            tofSensor.setTimeout(500);
            if (tofSensor.init()) {
                tofBus = &Wire1;
                groveUsedForI2C = true;
                tofSensor.startContinuous();
                tofInitialized = true;
                appEnabled[APP_DISTANCE] = true;
                appEnabled[APP_TOF_COUNTER] = true;
                Serial.println("  TOF sensor (VL53L0X) detected on Wire1 (Grove) at 0x29 -> Distance & TOF Counter enabled");
            } else {
                appEnabled[APP_DISTANCE] = false;
                appEnabled[APP_TOF_COUNTER] = false;
                Serial.println("  TOF sensor found on Wire1 but init failed -> Distance & TOF Counter disabled");
            }
        } else {
            tofBus = NULL;
            tofInitialized = false;
            appEnabled[APP_DISTANCE] = false;
            appEnabled[APP_TOF_COUNTER] = false;
            Serial.println("  TOF sensor not detected on either bus -> Distance & TOF Counter disabled");
        }
    }
    
    // Check for MiniScale sensor on both buses at address 0x26
    Wire.beginTransmission(MINISCALE_I2C_ADDR);
    if (Wire.endTransmission() == 0) {
        if (scales.begin(&Wire, QWIIC_SDA, QWIIC_SCL, MINISCALE_I2C_ADDR)) {
            scalesBus = &Wire;
            scalesInitialized = true;
            scales.setLEDColor(0x001000);  // Green LED
            appEnabled[APP_SCALE] = true;
            Serial.println("  MiniScale detected on Wire (Qwiic) at 0x26 -> Scale enabled");
        } else {
            appEnabled[APP_SCALE] = false;
            Serial.println("  MiniScale found on Wire but init failed -> Scale disabled");
        }
    } else {
        Wire1.beginTransmission(MINISCALE_I2C_ADDR);
        if (Wire1.endTransmission() == 0) {
            if (scales.begin(&Wire1, GROVE_SDA, GROVE_SCL, MINISCALE_I2C_ADDR)) {
                scalesBus = &Wire1;
                groveUsedForI2C = true;
                scalesInitialized = true;
                scales.setLEDColor(0x001000);  // Green LED
                appEnabled[APP_SCALE] = true;
                Serial.println("  MiniScale detected on Wire1 (Grove) at 0x26 -> Scale enabled");
            } else {
                appEnabled[APP_SCALE] = false;
                Serial.println("  MiniScale found on Wire1 but init failed -> Scale disabled");
            }
        } else {
            scalesBus = NULL;
            scalesInitialized = false;
            appEnabled[APP_SCALE] = false;
            Serial.println("  MiniScale not detected on either bus -> Scale disabled");
        }
    }
    
    // Check for ENV Pro sensor (BME688) on both buses at addresses 0x77 and 0x76
    // Try Wire (Qwiic) first at both addresses
    Wire.beginTransmission(BME68X_I2C_ADDR_HIGH);
    if (Wire.endTransmission() == 0) {
        envProBus = &Wire;
        envProI2CAddr = BME68X_I2C_ADDR_HIGH;
        Serial.println("  ENV Pro (BME688) detected on Wire (Qwiic) at 0x77");
    } else {
        Wire.beginTransmission(BME68X_I2C_ADDR_LOW);
        if (Wire.endTransmission() == 0) {
            envProBus = &Wire;
            envProI2CAddr = BME68X_I2C_ADDR_LOW;
            Serial.println("  ENV Pro (BME688) detected on Wire (Qwiic) at 0x76");
        }
    }
    
    // If not found on Wire, try Wire1 (Grove)
    if (envProBus == NULL) {
        Wire1.beginTransmission(BME68X_I2C_ADDR_HIGH);
        if (Wire1.endTransmission() == 0) {
            envProBus = &Wire1;
            envProI2CAddr = BME68X_I2C_ADDR_HIGH;
            groveUsedForI2C = true;
            Serial.println("  ENV Pro (BME688) detected on Wire1 (Grove) at 0x77");
        } else {
            Wire1.beginTransmission(BME68X_I2C_ADDR_LOW);
            if (Wire1.endTransmission() == 0) {
                envProBus = &Wire1;
                envProI2CAddr = BME68X_I2C_ADDR_LOW;
                groveUsedForI2C = true;
                Serial.println("  ENV Pro (BME688) detected on Wire1 (Grove) at 0x76");
            } else {
                envProBus = NULL;
                Serial.println("  ENV Pro (BME688) not detected on either bus at 0x76 or 0x77");
            }
        }
    }
    
    // Check for PIR motion sensor on Grove port (GPIO 33)
    // PIR uses GPIO 33 which conflicts with Grove SCL - only enable if Grove not used for I2C
    if (!groveUsedForI2C) {
        pinMode(PIR_PIN, INPUT);
        // appEnabled[APP_MOTION] = true;
        Serial.printf("  PIR sensor on GPIO %d -> Motion enabled (Grove not used for I2C)\n", PIR_PIN);
    } else {
        appEnabled[APP_MOTION] = false;
        Serial.println("  PIR disabled - GPIO 33 used for Grove I2C SCL");
    }
    
    // CRITICAL: Restore Wire1 to internal I2C pins (21/22) for AXP192 and RTC communication
    // Without this, battery status and RTC clock will not work!
    // We always restore to internal mode - sensors on Grove will switch as needed when reading
    switchWire1ToInternal();
    Serial.println("  Wire1 restored to internal I2C (GPIO 21/22) for AXP192/RTC");
    if (groveUsedForI2C) {
        Serial.println("  Note: Grove sensors will switch Wire1 temporarily when reading");
    }
    
    // Set initial app to first external sensor detected, fallback to IR Remote
    // External sensor apps: APP_AIR_QUALITY (CO2), APP_DISTANCE (TOF), APP_MOTION (PIR), APP_NCIR, APP_HEARTRATE
    // Internal apps (no sensor): APP_STOPWATCH, APP_TIMER, APP_IR_REMOTE
    currentApp = APP_IR_REMOTE;  // Default fallback when no external unit/hat detected
    
    // Priority order for external sensors: Distance (TOF), Air Quality (if CO2, SGP30, or ENV Pro), NCIR, Heart Rate, Motion
    if (appEnabled[APP_DISTANCE]) {
        currentApp = APP_DISTANCE;
    } else if (scd4xBus != NULL || sgp30Bus != NULL || envProBus != NULL) {  // Start with Air Quality if any air sensor detected
        currentApp = APP_AIR_QUALITY;
    } else if (appEnabled[APP_NCIR]) {
        currentApp = APP_NCIR;
    } else if (appEnabled[APP_HEARTRATE]) {
        currentApp = APP_HEARTRATE;
    } else if (appEnabled[APP_MOTION]) {
        currentApp = APP_MOTION;
    }
    
    Serial.printf("Starting with app: %s\n", appNames[currentApp]);
    
    // Initialize CO2 sensor on the detected I2C bus
    if (scd4xBus != NULL) {
        scd4x.begin(*scd4xBus, SCD40_I2C_ADDR_62);
        
        uint16_t error;
        // stop potentially previously started measurement
        error = scd4x.stopPeriodicMeasurement();
        if (error) {
            Serial.println("Error stopping measurement");
        }
        // Start Measurement
        error = scd4x.startPeriodicMeasurement();
        if (error) {
            Serial.println("Error starting measurement");
        } else {
            Serial.println("CO2 sensor initialized. Waiting for first measurement... (5 sec)");
        }
    }
    
    // Initialize SGP30 TVOC/eCO2 sensor on the detected I2C bus
    if (sgp30Bus != NULL) {
        if (sgp30.begin(sgp30Bus)) {
            sgp30Initialized = true;
            Serial.println("SGP30 TVOC/eCO2 sensor initialized");
            Serial.print("  Found SGP30 serial #");
            Serial.print(sgp30.serialnumber[0], HEX);
            Serial.print(sgp30.serialnumber[1], HEX);
            Serial.println(sgp30.serialnumber[2], HEX);
        } else {
            sgp30Initialized = false;
            Serial.println("SGP30 initialization failed");
        }
    }
    
    // Initialize ENV Pro sensor (BME688 with BSEC2) on the detected I2C bus
    if (envProBus != NULL) {
        // Switch Wire1 to Grove if ENV Pro is on Grove port
        if (envProBus == &Wire1) {
            switchWire1ToGrove();
            Serial.println("Switched Wire1 to Grove for ENV Pro init");
        }
        
        // BSEC2 sensor subscription list
        bsecSensor sensorList[] = {
            BSEC_OUTPUT_IAQ,
            BSEC_OUTPUT_RAW_TEMPERATURE,
            BSEC_OUTPUT_RAW_PRESSURE,
            BSEC_OUTPUT_RAW_HUMIDITY,
            BSEC_OUTPUT_RAW_GAS,
            BSEC_OUTPUT_STABILIZATION_STATUS,
            BSEC_OUTPUT_RUN_IN_STATUS
        };
        
        Serial.printf("Attempting BSEC2 begin at 0x%02X on %s...\n", envProI2CAddr, 
                      (envProBus == &Wire) ? "Wire" : "Wire1");
        
        if (envProSensor.begin(envProI2CAddr, *envProBus)) {
            Serial.println("BSEC2 begin() succeeded");
            Serial.println("BSEC library version " + String(envProSensor.version.major) + "." + 
                           String(envProSensor.version.minor) + "." + 
                           String(envProSensor.version.major_bugfix) + "." + 
                           String(envProSensor.version.minor_bugfix));
            
            Serial.printf("Subscribing to %d outputs at ULP rate...\n", ARRAY_LEN(sensorList));
            if (envProSensor.updateSubscription(sensorList, ARRAY_LEN(sensorList), BSEC_SAMPLE_RATE_ULP)) {
                envProSensor.attachCallback(envProDataCallback);
                envProInitialized = true;
                appEnabled[APP_AIR_QUALITY] = true;  // Enable air quality if ENV Pro is present
                Serial.println("ENV Pro (BSEC2) initialized successfully");
            } else {
                Serial.println("ENV Pro BSEC2 subscription failed");
                Serial.println("BSEC status: " + String(envProSensor.status));
                Serial.println("BME68X status: " + String(envProSensor.sensor.status));
            }
        } else {
            Serial.println("ENV Pro BSEC2 init failed");
            if (envProSensor.sensor.status < BME68X_OK) {
                Serial.println("BME68X error code: " + String(envProSensor.sensor.status));
            }
        }
        
        // Restore Wire1 to internal for AXP192/RTC after ENV Pro init
        if (envProBus == &Wire1) {
            switchWire1ToInternal();
            Serial.println("Restored Wire1 to internal after ENV Pro init");
        }
    }
    
    tftSprite.setRotation(1);
    tftSprite.createSprite(135, 240);
    tftSprite.setTextSize(1);
    delay_time  = 20;
    if (encoderConnected) {
        i2c_address = sensor.getI2CAddress();
    }
    
// Load history from flash
    loadHistory();
    last_sample_time = millis();
    last_save_time = millis();
    
    // Mi Band BLE will be initialized on demand when alarm is armed and setting enabled
    Serial.printf("Free heap at startup: %d\n", ESP.getFreeHeap());
}

void loop() {
    M5.update();
    
    // Handle web server requests when WiFi is enabled
    if (webFilesWiFiEnabled) {
        webFilesServer.handleClient();
    }
    
    // Handle app navigation and input
    handleAppInput();
    
    // Read CO2 sensor values when available (always, for background data collection)
    if (scd4xBus != NULL) {
        // Switch to Grove if sensor is on Grove port
        if (scd4xBus == &Wire1) switchWire1ToGrove();
        
        bool isDataReady = false;
        scd4x.getDataReadyStatus(isDataReady);
        if (isDataReady) {
            uint16_t error = scd4x.readMeasurement(co2_value, temperature, humidity);
            if (error == 0) {
                Serial.printf("CO2: %d ppm, Temp: %.1f C, Hum: %.1f %%\n", 
                              co2_value, temperature, humidity);
            }
        }
        
        // Restore Wire1 to internal for AXP192/RTC
        if (scd4xBus == &Wire1) switchWire1ToInternal();
    }
    
    // Read SGP30 TVOC/eCO2 sensor (every 1 second as per datasheet)
    if (sgp30Initialized && (millis() - sgp30LastRead >= SGP30_READ_INTERVAL)) {
        // Switch to Grove if sensor is on Grove port
        if (sgp30Bus == &Wire1) switchWire1ToGrove();
        
        if (sgp30.IAQmeasure()) {
            sgp30TVOC = sgp30.TVOC;
            sgp30eCO2 = sgp30.eCO2;
            
            // Set humidity compensation if ENV Pro is available
            // Formula from Sensirion: absolute humidity in mg/m³
            if (envProInitialized && envProHumidity > 0) {
                // Calculate absolute humidity from relative humidity and temperature
                // Using simplified formula: AH = 216.7 * (RH/100 * 6.112 * exp(17.62*T/(243.12+T)) / (273.15+T))
                float absHumidity = 216.7f * (envProHumidity / 100.0f * 6.112f * 
                    exp(17.62f * envProTemperature / (243.12f + envProTemperature)) / 
                    (273.15f + envProTemperature));
                // Convert to fixed point 8.8 format (mg/m³ * 256)
                uint16_t absHumFixed = (uint16_t)(absHumidity * 256.0f);
                sgp30.setHumidity(absHumFixed);
            }
        }
        sgp30LastRead = millis();
        
        // Restore Wire1 to internal for AXP192/RTC
        if (sgp30Bus == &Wire1) switchWire1ToInternal();
    }
    
    // Run ENV Pro BSEC2 sensor (processes data and calls callback when ready)
    if (envProInitialized) {
        // Switch to Grove if sensor is on Grove port
        if (envProBus == &Wire1) switchWire1ToGrove();
        
        if (!envProSensor.run()) {
            // Check for errors
            if (envProSensor.status < BSEC_OK) {
                Serial.println("BSEC error: " + String(envProSensor.status));
            }
        }
        
        // Restore Wire1 to internal for AXP192/RTC
        if (envProBus == &Wire1) switchWire1ToInternal();
    }
    
    // Sample data for history (every 10 minutes) - sample if CO2 or ENV Pro data available
    unsigned long now = millis();
    bool hasData = (co2_value > 0) || (envProInitialized && envProTemperature != 0);
    if (hasData && (now - last_sample_time >= SAMPLE_INTERVAL_MS)) {
        addSample();
        last_sample_time = now;
        Serial.printf("Sample added: %d/%d\n", history_count, HISTORY_SIZE);
    }
    
    // Save to flash periodically
    if (now - last_save_time >= SAVE_INTERVAL_MS) {
        saveHistory();
        last_save_time = now;
    }
    
    // Render current app screen
    renderCurrentApp();
    delay(100);
}
